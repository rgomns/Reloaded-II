{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Reloaded II Universal, C# based mod framework. Works with anything X86, X64. What is Reloaded II [Reloaded II] is a Swiss army knife universal Game Modding framework. It is an extensible and modular framework that allows you to create your own mods for any game. Mod Loader Highly Supported Can be used in any 32-bit or 64-bit game. Easy to integrate with other mod loaders. Modular & Extensible Minimal core. Does nothing unnecessary. Extra functionality provided via mods themselves . Write Mods using .NET Fast development time with easy to learn C#. Doesn't mean native mods aren't supported \ud83d\ude09. Integrated Logging Logs to console and file in real time. And perhaps with a universal mod, to the screen too! High Performance Reloaded is built for performance. Modern runtime, low overhead, fast startup times. Dependency System Mods can set requirements on other mods. The loader will ensure they're loaded before your mod. Early Hook Your code executes before the game runs a single line of code. Hot Reload Load & Unload supported mods at runtime. Or even remotely, API available! Debugging Support Debug & Profile your code in Visual Studio Including Edit & Support 1 . Mod Conflict Security Mods are executed in isolation. Use libraries & NuGet packages without worrying. Mod Framework & Launcher Automatic Installer Install Reloaded & Runtimes with a single click. Very fast, completes in under 30 seconds. Automatic Updates For everything: Launcher, Loader & Mods. Includes super cool Delta Update technology. Built-in Mod Configuration Mods configurable directly from launcher. Changes apply in real time! Familiar UI Including built-in tutorial. Can be themed and translated to any language. Multi-Game Launcher Supports multiple games at once. Only one copy of Reloaded is needed! Mod Sets Save/Load list of mods to be loaded by game. No need to furiously check and uncheck boxes. Clean Install/Uninstall Doesn't modify your game's files. Self contained. Remove Reloaded folder and it's gone. Enhanced Download Experience Built-in mod downloader. 1-click downloads on supported websites. Portable Carry your Reloaded with you. Move your mods to any directory. Made with LOVE By yours truly. Have a great day. Platform Support Todo This wiki needs troubleshooting information for non-Windows users. If you have experience with setting up Reloaded on Wine, consider contributing to this wiki. Reloaded is natively a Windows application, however active effort is undertaken to ensure compatibility with Wine. Operating System Description Windows \u2705 Native Linux \u2705 Wine (+ Proton) OSX \u26a0\ufe0f Wine (Reportedly works) Other \u2753 Unknown. Architecture Natively Supported x86 \u2705 x86_64 \u2705 Windows on ARM \u2753 Unknown. ARM \u274c Contributions Contributions to this project are highly encouraged . Feel free to implement new features, make bug fixes or suggestions so long as they are accompanied by an issue with a clear description of the pull request. Documentation is just as welcome as code changes! You need to set COMPLUS_FORCEENC = 1 environment variable. \u21a9","title":"Home"},{"location":"#what-is-reloaded-ii","text":"[Reloaded II] is a Swiss army knife universal Game Modding framework. It is an extensible and modular framework that allows you to create your own mods for any game.","title":"What is Reloaded II"},{"location":"#mod-loader","text":"Highly Supported Can be used in any 32-bit or 64-bit game. Easy to integrate with other mod loaders. Modular & Extensible Minimal core. Does nothing unnecessary. Extra functionality provided via mods themselves . Write Mods using .NET Fast development time with easy to learn C#. Doesn't mean native mods aren't supported \ud83d\ude09. Integrated Logging Logs to console and file in real time. And perhaps with a universal mod, to the screen too! High Performance Reloaded is built for performance. Modern runtime, low overhead, fast startup times. Dependency System Mods can set requirements on other mods. The loader will ensure they're loaded before your mod. Early Hook Your code executes before the game runs a single line of code. Hot Reload Load & Unload supported mods at runtime. Or even remotely, API available! Debugging Support Debug & Profile your code in Visual Studio Including Edit & Support 1 . Mod Conflict Security Mods are executed in isolation. Use libraries & NuGet packages without worrying.","title":"Mod Loader"},{"location":"#mod-framework-launcher","text":"Automatic Installer Install Reloaded & Runtimes with a single click. Very fast, completes in under 30 seconds. Automatic Updates For everything: Launcher, Loader & Mods. Includes super cool Delta Update technology. Built-in Mod Configuration Mods configurable directly from launcher. Changes apply in real time! Familiar UI Including built-in tutorial. Can be themed and translated to any language. Multi-Game Launcher Supports multiple games at once. Only one copy of Reloaded is needed! Mod Sets Save/Load list of mods to be loaded by game. No need to furiously check and uncheck boxes. Clean Install/Uninstall Doesn't modify your game's files. Self contained. Remove Reloaded folder and it's gone. Enhanced Download Experience Built-in mod downloader. 1-click downloads on supported websites. Portable Carry your Reloaded with you. Move your mods to any directory. Made with LOVE By yours truly. Have a great day.","title":"Mod Framework &amp; Launcher"},{"location":"#platform-support","text":"Todo This wiki needs troubleshooting information for non-Windows users. If you have experience with setting up Reloaded on Wine, consider contributing to this wiki. Reloaded is natively a Windows application, however active effort is undertaken to ensure compatibility with Wine. Operating System Description Windows \u2705 Native Linux \u2705 Wine (+ Proton) OSX \u26a0\ufe0f Wine (Reportedly works) Other \u2753 Unknown. Architecture Natively Supported x86 \u2705 x86_64 \u2705 Windows on ARM \u2753 Unknown. ARM \u274c","title":"Platform Support"},{"location":"#contributions","text":"Contributions to this project are highly encouraged . Feel free to implement new features, make bug fixes or suggestions so long as they are accompanied by an issue with a clear description of the pull request. Documentation is just as welcome as code changes! You need to set COMPLUS_FORCEENC = 1 environment variable. \u21a9","title":"Contributions"},{"location":"APIOverview/","text":"API Overview In Reloaded II, in-process communication between mods and the loader as well as Inter Mod Communication (IMC) is performed mainly through the use of extensible interfaces that can be found in the Reloaded.Mod.Interfaces namespace. Reloaded.Mod.Interfaces is contained and distributed as a tiny interface only library that contains various interfaces such as IModLoader or IMod . It is included by default in Reloaded mod projects and also available as a NuGet package. Variants of Communication This feature (the use of interfaces for communication) is entirely optional. Most mods will probably not need to make use of it - this is for more complex mods. That said, the use of the Reloaded.Mod.Interfaces is compulsory, as it provides the IMod interface used by the mod loader to find an entry point to execute user mods. Mod to Loader Communication Mod to loader communication is used to provide various miniature mod loader services such as but not limited to: - Querying the mod loader version. - Writing to the console. - Inter Mod Communication (IMC). - Receiving events on mod load, unload etc. The communication between the mod and the mod loader is handled by the IModLoader interface. IModLoader interface is immediately available to you in the entry point of your mods, as the IModLoader interface is provided as a parameter of the Start method of the IMod interface. Mod to Mod Communication Reloaded's own Mod to Mod communication (Inter Mod Communication) is performed through the use of the aforementioned IModLoader interface that allows for interaction with the mod loader. Reloaded-II provides two mechanisms for what it considers \"Inter Mod Communication\", dubbed \"Plugins and Controllers\". Plugins allow you to extend the functionality of other mods by implementing interfaces defined by them inside your mod. The mod loader API searches, creates and returns new instances of classes implementing a specific interface from other mods. In other words, plugins do not share state. Controllers allow you to directly interact with other loaded mods. Individual mods can submit shared instances of interfaces to the mod loader, which can then be obtained by other mods. Controllers share state. Complete documentation on Mod to Mod communication can be found within the Inter Mod Communication documentation. API Upgrades & Versioning Updates to the mod loader API as well as all general interfaces are expected to be very infrequent. Frequency will depend on developer requests however the estimate is less than once a year. Backwards Compatibility: Mod & Loader Interfaces As time progresses and new features are added, Reloaded-II needs to preserve compatibility with old mods using older interfaces, how does Reloaded-II plan to achieve this? The answer to this specific question can be summed up with the word inheritance , specifically the inheritance of interfaces. Specifically, Reloaded interfaces used for communication follow a strict set of rules: All versions of interfaces extend from the previous version. When passing interfaces between boundaries of different isolated units (e.g. Mod to Loader), the first version of the interface is always used. Receivers obtaining the interface promote it by casting to the newest available version known to them. public static void Start ( IModLoaderV1 loader ) { _loader = ( IModLoader ) loader ; // IModLoader is an empty interface that extends from the most recent version, e.g. IModLoaderV3 // This allows for auto-upgrading interface by updating NuGet package without changing base code. } Mod Loader Server Reloaded-II also supports out-of-process communication through the use of a locally hosted server inside each process which has loaded Reloaded. The data structures, list of server calls and responses of the server can be found in the separate Reloaded.Mod.Loader.Server project. That said, this server is only intended for internal use by the launcher to allow for status reporting and basic mod management. Backwards Compatibility: Mod Loader Server Backwards compatibility at server end for requests is handled in the following simple way: The Server accepts all available requests available in the most recent version of Reloaded-II, regardless of whether it may be always supported. If a given mod-related request is not supported by a mod, the Server will return a ReloadedException with an accompanying error message. Example: \"Feature unavailable. Interface IModV2 is not supported by this mod.\" .","title":"API Overview"},{"location":"APIOverview/#api-overview","text":"In Reloaded II, in-process communication between mods and the loader as well as Inter Mod Communication (IMC) is performed mainly through the use of extensible interfaces that can be found in the Reloaded.Mod.Interfaces namespace. Reloaded.Mod.Interfaces is contained and distributed as a tiny interface only library that contains various interfaces such as IModLoader or IMod . It is included by default in Reloaded mod projects and also available as a NuGet package.","title":"API Overview"},{"location":"APIOverview/#variants-of-communication","text":"This feature (the use of interfaces for communication) is entirely optional. Most mods will probably not need to make use of it - this is for more complex mods. That said, the use of the Reloaded.Mod.Interfaces is compulsory, as it provides the IMod interface used by the mod loader to find an entry point to execute user mods.","title":"Variants of Communication"},{"location":"APIOverview/#mod-to-loader-communication","text":"Mod to loader communication is used to provide various miniature mod loader services such as but not limited to: - Querying the mod loader version. - Writing to the console. - Inter Mod Communication (IMC). - Receiving events on mod load, unload etc. The communication between the mod and the mod loader is handled by the IModLoader interface. IModLoader interface is immediately available to you in the entry point of your mods, as the IModLoader interface is provided as a parameter of the Start method of the IMod interface.","title":"Mod to Loader Communication"},{"location":"APIOverview/#mod-to-mod-communication","text":"Reloaded's own Mod to Mod communication (Inter Mod Communication) is performed through the use of the aforementioned IModLoader interface that allows for interaction with the mod loader. Reloaded-II provides two mechanisms for what it considers \"Inter Mod Communication\", dubbed \"Plugins and Controllers\". Plugins allow you to extend the functionality of other mods by implementing interfaces defined by them inside your mod. The mod loader API searches, creates and returns new instances of classes implementing a specific interface from other mods. In other words, plugins do not share state. Controllers allow you to directly interact with other loaded mods. Individual mods can submit shared instances of interfaces to the mod loader, which can then be obtained by other mods. Controllers share state. Complete documentation on Mod to Mod communication can be found within the Inter Mod Communication documentation.","title":"Mod to Mod Communication"},{"location":"APIOverview/#api-upgrades-versioning","text":"Updates to the mod loader API as well as all general interfaces are expected to be very infrequent. Frequency will depend on developer requests however the estimate is less than once a year.","title":"API Upgrades &amp; Versioning"},{"location":"APIOverview/#backwards-compatibility-mod-loader-interfaces","text":"As time progresses and new features are added, Reloaded-II needs to preserve compatibility with old mods using older interfaces, how does Reloaded-II plan to achieve this? The answer to this specific question can be summed up with the word inheritance , specifically the inheritance of interfaces. Specifically, Reloaded interfaces used for communication follow a strict set of rules: All versions of interfaces extend from the previous version. When passing interfaces between boundaries of different isolated units (e.g. Mod to Loader), the first version of the interface is always used. Receivers obtaining the interface promote it by casting to the newest available version known to them. public static void Start ( IModLoaderV1 loader ) { _loader = ( IModLoader ) loader ; // IModLoader is an empty interface that extends from the most recent version, e.g. IModLoaderV3 // This allows for auto-upgrading interface by updating NuGet package without changing base code. }","title":"Backwards Compatibility: Mod &amp; Loader Interfaces"},{"location":"APIOverview/#mod-loader-server","text":"Reloaded-II also supports out-of-process communication through the use of a locally hosted server inside each process which has loaded Reloaded. The data structures, list of server calls and responses of the server can be found in the separate Reloaded.Mod.Loader.Server project. That said, this server is only intended for internal use by the launcher to allow for status reporting and basic mod management.","title":"Mod Loader Server"},{"location":"APIOverview/#backwards-compatibility-mod-loader-server","text":"Backwards compatibility at server end for requests is handled in the following simple way: The Server accepts all available requests available in the most recent version of Reloaded-II, regardless of whether it may be always supported. If a given mod-related request is not supported by a mod, the Server will return a ReloadedException with an accompanying error message. Example: \"Feature unavailable. Interface IModV2 is not supported by this mod.\" .","title":"Backwards Compatibility: Mod Loader Server"},{"location":"AddingModFunctionality/","text":"Adding Functionality (Example) Info The following guide will walk you through adding functionality to a your (non-code) mod through the use of other mods. In this guide we will be using the universal Reloaded File Redirector Mod to replace files that will be loaded by the game (any game!). Download the Mod First of all, download the mod which we will be using to extend the functionality of our mod. In this case, the Reloaded File Redirector . Add Dependency to Other Mod In the Edit Mod menu we're going to add Reloaded File Redirector as a dependency. Adding a 'dependency' to your mod will make it such that the other mod will always be loaded when your mod is loaded. This is a necessary step. Following the Guide Mods such as File Redirector will typically include guides on using them; which can typically be found on their download page. Here is the guide for the File Redirector from the GitHub page : We've already done Step A by adding the dependency; let's follow the rest of this guide! Opening the Mod Folder Go to the folder where your mod is stored, this can be done by simply clicking the Open Fodler button. Add Some Files Make a folder called Redirector . Inside it place files that we want to be replaced. The contents of our mod folder now look as follows. // Mod Contents ModConfig.json Preview.png Redirector \u2514\u2500dvdroot \u251c\u2500advertise \u2502 adv_pl_rouge.one \u2514\u2500playmodel ro.txd ro_dff.one The connectors \u2514\u2500 represent folders. Summary That's all folks.","title":"2. Adding Functionality"},{"location":"AddingModFunctionality/#adding-functionality-example","text":"Info The following guide will walk you through adding functionality to a your (non-code) mod through the use of other mods. In this guide we will be using the universal Reloaded File Redirector Mod to replace files that will be loaded by the game (any game!).","title":"Adding Functionality (Example)"},{"location":"AddingModFunctionality/#download-the-mod","text":"First of all, download the mod which we will be using to extend the functionality of our mod. In this case, the Reloaded File Redirector .","title":"Download the Mod"},{"location":"AddingModFunctionality/#add-dependency-to-other-mod","text":"In the Edit Mod menu we're going to add Reloaded File Redirector as a dependency. Adding a 'dependency' to your mod will make it such that the other mod will always be loaded when your mod is loaded. This is a necessary step.","title":"Add Dependency to Other Mod"},{"location":"AddingModFunctionality/#following-the-guide","text":"Mods such as File Redirector will typically include guides on using them; which can typically be found on their download page. Here is the guide for the File Redirector from the GitHub page : We've already done Step A by adding the dependency; let's follow the rest of this guide!","title":"Following the Guide"},{"location":"AddingModFunctionality/#opening-the-mod-folder","text":"Go to the folder where your mod is stored, this can be done by simply clicking the Open Fodler button.","title":"Opening the Mod Folder"},{"location":"AddingModFunctionality/#add-some-files","text":"Make a folder called Redirector . Inside it place files that we want to be replaced. The contents of our mod folder now look as follows. // Mod Contents ModConfig.json Preview.png Redirector \u2514\u2500dvdroot \u251c\u2500advertise \u2502 adv_pl_rouge.one \u2514\u2500playmodel ro.txd ro_dff.one The connectors \u2514\u2500 represent folders.","title":"Add Some Files"},{"location":"AddingModFunctionality/#summary","text":"That's all folks.","title":"Summary"},{"location":"AddingUpdateSupport/","text":"Adding Support (for Programmers) Note The following guidance is for programmers wishing to add update support to their own websites to Reloaded. Support for mod updates is provided using the Sewer56/Update library. Use the following steps to add update support to your website. Preface Please use the namespace Reloaded.Mod.Loader.Update.Providers.YOUR_SERVICE_HERE for your website/service. 1. Write an Update Resolver Create a package resolver ( IPackageResolver ) by following the guidelines at wiki:Update/Package Resolvers . You can find additional examples in the Update library itself. 2. Write a Resolver Factory Create a class that implements the IUpdateResolverFactory class inside Reloaded.Mod.Loader.Update.Providers , returning your IPackageResolver via GetResolver() . Example: See GameBananaUpdateResolverFactory . 3. Register your Resolver Factory When you are done, update ResolverFactory.All to include your new IUpdateResolverFactory .","title":"Adding Mod Update Support"},{"location":"AddingUpdateSupport/#adding-support-for-programmers","text":"Note The following guidance is for programmers wishing to add update support to their own websites to Reloaded. Support for mod updates is provided using the Sewer56/Update library. Use the following steps to add update support to your website.","title":"Adding Support (for Programmers)"},{"location":"AddingUpdateSupport/#preface","text":"Please use the namespace Reloaded.Mod.Loader.Update.Providers.YOUR_SERVICE_HERE for your website/service.","title":"Preface"},{"location":"AddingUpdateSupport/#1-write-an-update-resolver","text":"Create a package resolver ( IPackageResolver ) by following the guidelines at wiki:Update/Package Resolvers . You can find additional examples in the Update library itself.","title":"1. Write an Update Resolver"},{"location":"AddingUpdateSupport/#2-write-a-resolver-factory","text":"Create a class that implements the IUpdateResolverFactory class inside Reloaded.Mod.Loader.Update.Providers , returning your IPackageResolver via GetResolver() . Example: See GameBananaUpdateResolverFactory .","title":"2. Write a Resolver Factory"},{"location":"AddingUpdateSupport/#3-register-your-resolver-factory","text":"When you are done, update ResolverFactory.All to include your new IUpdateResolverFactory .","title":"3. Register your Resolver Factory"},{"location":"BuildingReloaded/","text":"Prerequisites .NET 6.0 SDK (or newer). Visual Studio 2019+ \"Desktop development with C++\" workload (Windows 10 SDK) Obtaining Reloaded Clone this repository and fetch the submodules. git clone https://github.com/Reloaded-Project/Reloaded-II cd Reloaded-II git submodule update --init --recursive Building Reloaded Open 'Source/Reloaded-II.sln' in Visual Studio. Build. You're done (* ^ \u03c9 ^), go play around! Releasing Reloaded To distribute Reloaded, build it using the publish script Publish.ps1 . Search for and open Developer Command Prompt for VS 2019 . Change current directory to the Source directory. Open Powershell by typing in powershell . Execute .\\Publish.ps1 . The output should reside in the Publish folder.","title":"Building Reloaded"},{"location":"BuildingReloaded/#prerequisites","text":".NET 6.0 SDK (or newer). Visual Studio 2019+ \"Desktop development with C++\" workload (Windows 10 SDK)","title":"Prerequisites"},{"location":"BuildingReloaded/#obtaining-reloaded","text":"Clone this repository and fetch the submodules. git clone https://github.com/Reloaded-Project/Reloaded-II cd Reloaded-II git submodule update --init --recursive","title":"Obtaining Reloaded"},{"location":"BuildingReloaded/#building-reloaded","text":"Open 'Source/Reloaded-II.sln' in Visual Studio. Build. You're done (* ^ \u03c9 ^), go play around!","title":"Building Reloaded"},{"location":"BuildingReloaded/#releasing-reloaded","text":"To distribute Reloaded, build it using the publish script Publish.ps1 . Search for and open Developer Command Prompt for VS 2019 . Change current directory to the Source directory. Open Powershell by typing in powershell . Execute .\\Publish.ps1 . The output should reside in the Publish folder.","title":"Releasing Reloaded"},{"location":"ContributingLocally/","text":"Contributing to the Wiki: Locally Tutorial You should learn the basics of git , an easy way is to give GitHub Desktop (Tutorial) a go. It's only 15 minutes \ud83d\ude00. Create a GitHub account. Fork this repository: This will create a copy of the repository on your own user account, which you will be able to edit. Clone this repository. For example, using GitHub Desktop: Make changes inside the docs folder. Consider using a Markdown Cheat Sheet if you are new to markdown. I recommend using a markdown editor such as Typora . Personally I use Visual Studio Code , which has built-in markdown support and preview available ( Ctrl+Shift+P -> Markdown: Open Preview ). Commit the changes and push to GitHub. Open a Pull Request . Opening a Pull Request will allow us to review your changes before adding them with the main official page. If everything's good, we'll hit the merge button and add your changes to the official repository. Website Live Preview If you are working on the wiki locally, you can generate a live preview the full website. Here's a quick guide of how you could do it from your command prompt (cmd). Install Python 3 If you have winget installed, or Windows 11, you can do this from the command prompt. winget install Python.Python.3 Otherwise download Python 3 from the official website. Install Material for MkDocs and Plugins (Python package) # Restart your command prompt before running this command. pip install mkdocs-material pip install mkdocs-redirects Open a command prompt in the folder containing mkdocs.yml . and run the site locally. # Move to project folder. cd <Replace this with full path to folder containing ` mkdocs.yml ` > mkdocs serve Copy the address to your web browser and enjoy the live preview; any changes you save will be shown instantly.","title":"Contributing Locally"},{"location":"ContributingLocally/#contributing-to-the-wiki-locally","text":"","title":"Contributing to the Wiki: Locally"},{"location":"ContributingLocally/#tutorial","text":"You should learn the basics of git , an easy way is to give GitHub Desktop (Tutorial) a go. It's only 15 minutes \ud83d\ude00. Create a GitHub account. Fork this repository: This will create a copy of the repository on your own user account, which you will be able to edit. Clone this repository. For example, using GitHub Desktop: Make changes inside the docs folder. Consider using a Markdown Cheat Sheet if you are new to markdown. I recommend using a markdown editor such as Typora . Personally I use Visual Studio Code , which has built-in markdown support and preview available ( Ctrl+Shift+P -> Markdown: Open Preview ). Commit the changes and push to GitHub. Open a Pull Request . Opening a Pull Request will allow us to review your changes before adding them with the main official page. If everything's good, we'll hit the merge button and add your changes to the official repository.","title":"Tutorial"},{"location":"ContributingLocally/#website-live-preview","text":"If you are working on the wiki locally, you can generate a live preview the full website. Here's a quick guide of how you could do it from your command prompt (cmd). Install Python 3 If you have winget installed, or Windows 11, you can do this from the command prompt. winget install Python.Python.3 Otherwise download Python 3 from the official website. Install Material for MkDocs and Plugins (Python package) # Restart your command prompt before running this command. pip install mkdocs-material pip install mkdocs-redirects Open a command prompt in the folder containing mkdocs.yml . and run the site locally. # Move to project folder. cd <Replace this with full path to folder containing ` mkdocs.yml ` > mkdocs serve Copy the address to your web browser and enjoy the live preview; any changes you save will be shown instantly.","title":"Website Live Preview"},{"location":"ContributingOnline/","text":"Contributing to the Wiki: Online (If you want to work purely in your web browser, recommended for small changes only) Create a GitHub Account. Fork this repository: This will create a copy of the repository on your own user account, which you will be able to edit. Open the docs folder and edit the relevant (.md) pages. Consider using a Markdown Cheat Sheet for your editing needs. Open a Pull Request . Opening a Pull Request will allow us to review your changes before adding them with the main official page. If everything's good, we'll hit the merge button and add your changes to the official repository.","title":"Contributing Online"},{"location":"ContributingOnline/#contributing-to-the-wiki-online","text":"(If you want to work purely in your web browser, recommended for small changes only) Create a GitHub Account. Fork this repository: This will create a copy of the repository on your own user account, which you will be able to edit. Open the docs folder and edit the relevant (.md) pages. Consider using a Markdown Cheat Sheet for your editing needs. Open a Pull Request . Opening a Pull Request will allow us to review your changes before adding them with the main official page. If everything's good, we'll hit the merge button and add your changes to the official repository.","title":"Contributing to the Wiki: Online"},{"location":"CreatingMods/","text":"Creating Mods Note This section is for non-programmers wishing to create mods which take advantage of existing mods/plugins (such as file redirection). If you intend on programming with Reloaded, please see Programmers' Getting Started instead. Create A Configuration File The first step towards creating a mod is to make a configuration file. This can be simply done by entering the Manage Mods (3 gears) menu and clicking the New button. For the Mod Id you should enter a name that is unique to your mod. The format game.type.name is suggested, for example sonicheroes.asset.seasidehillmidnight . This name should be human readable. Edit the Mod Configuration Note You can access this menu in the future by selecting the mod and clicking Edit in the Manage Mods menu, or by right clicking the mod in any game's mod list. Main Mod Details Set the following mod properties. - Name: The name of the mod a seen in the launcher. - Author: The name of the author(s) of the mod. - Version: The version of the mod. - Description: Short summary of the mod. For the Version field, Reloaded uses Semantic Versioning . In simple terms, please use the X.Y.Z format for your versions and increment: - X when you make big/breaking changes that fundamentally change your mod. (Example: Major game rebalance) - Y when you add new features without breaking existing functionality. (Example: Add stage to stage pack) - Z when you add new bug fixes. (Example: Fixed bad texture) Update the Preview Image To set the preview image, click on the image above the Name field. Although any resolution is accepted, it is recommended that your preview image is 256x256 in size (or a multiple like 512x512 ). This is the size it will be displayed at to most users. Add Game Support to Mod Select the game(s) you wish to support from the dropdown menu. This will make it so that your mod will be visible in that specific game's mod list. Summary By the end of this guide, you should have a newly created mod, which will be visible in your game's mods list. Next: Adding Mod Functionality","title":"1. Creating Your Mod"},{"location":"CreatingMods/#creating-mods","text":"Note This section is for non-programmers wishing to create mods which take advantage of existing mods/plugins (such as file redirection). If you intend on programming with Reloaded, please see Programmers' Getting Started instead.","title":"Creating Mods"},{"location":"CreatingMods/#create-a-configuration-file","text":"The first step towards creating a mod is to make a configuration file. This can be simply done by entering the Manage Mods (3 gears) menu and clicking the New button. For the Mod Id you should enter a name that is unique to your mod. The format game.type.name is suggested, for example sonicheroes.asset.seasidehillmidnight . This name should be human readable.","title":"Create A Configuration File"},{"location":"CreatingMods/#edit-the-mod-configuration","text":"Note You can access this menu in the future by selecting the mod and clicking Edit in the Manage Mods menu, or by right clicking the mod in any game's mod list.","title":"Edit the Mod Configuration"},{"location":"CreatingMods/#main-mod-details","text":"Set the following mod properties. - Name: The name of the mod a seen in the launcher. - Author: The name of the author(s) of the mod. - Version: The version of the mod. - Description: Short summary of the mod. For the Version field, Reloaded uses Semantic Versioning . In simple terms, please use the X.Y.Z format for your versions and increment: - X when you make big/breaking changes that fundamentally change your mod. (Example: Major game rebalance) - Y when you add new features without breaking existing functionality. (Example: Add stage to stage pack) - Z when you add new bug fixes. (Example: Fixed bad texture)","title":"Main Mod Details"},{"location":"CreatingMods/#update-the-preview-image","text":"To set the preview image, click on the image above the Name field. Although any resolution is accepted, it is recommended that your preview image is 256x256 in size (or a multiple like 512x512 ). This is the size it will be displayed at to most users.","title":"Update the Preview Image"},{"location":"CreatingMods/#add-game-support-to-mod","text":"Select the game(s) you wish to support from the dropdown menu. This will make it so that your mod will be visible in that specific game's mod list.","title":"Add Game Support to Mod"},{"location":"CreatingMods/#summary","text":"By the end of this guide, you should have a newly created mod, which will be visible in your game's mods list. Next: Adding Mod Functionality","title":"Summary"},{"location":"CreatingRelease/","text":"Uploading Mods Before uploading a mod, you should first create a Release . A Release consists of 2 files: - Compressed version of your mod. - JSON text file containing update information. Creating Releases From the Launcher In order to create a release for a mod, right click the mod and hit Publish in an individual application's main page. Select the Publish Target from the dropdown. (Use Default if your website/location is not present in the list.) Click Publish, and upload the generated .7z files and .json file to the world. From the Commandline Note If you are making a code mod, it is recommended to use the Publish script from the Mod Template . The following instructions are provided for people wishing to make their own build scripts. Reloaded comes with a set of tools that can be used to create releases outside of the launcher. Reloaded.Publisher.exe [Recommended]: Publishes a release for a mod. Identical features to GUI's Publish Mod menu. NuGetConverter.exe [Legacy]: Automatically creates a NuGet package given a mod folder or a mod zip. You can get them from either of the 2 sources: Via GitHub Releases ( Tools.zip ). Via Chocolatey . Delta Updates Reloaded allows for the creation and usage of delta updates. A delta update is an update that only requires the user to download the code and data that has changed instead of the whole mod. If version 1.0.1 adds 8MB worth of files, the user will only need to download 8MB to update from 1.0.0 (instead of e.g. 500MB ) for a big mod. If 1MB out of a 100MB file is changed, the user will only need to download 1MB , not 100MB . To create a delta update, do the following: - Download the previous version of your mod (including .json file!). - Check Automatic Delta in Delta Update tab. - Set Output Folder to the location of the previous update. Note If you have an unpacked version of your previous mod, i.e. as a raw folder; you can add that in the Delta Update tab instead. Uploading to NuGet When creating a release, please select the NuGet publish target. This should output a .nupkg file, which you will upload. The easiest way to upload a package is to install the .NET SDK and use the dotnet commandline utility. Example: # Upload package.nupkg to the official Reloaded server. dotnet nuget push -s http://packages.sewer56.moe:5000/v3/index.json -k API-KEY package.nupkg Upload instructions for the official Reloaded package server .","title":"2. Creating a Release"},{"location":"CreatingRelease/#uploading-mods","text":"Before uploading a mod, you should first create a Release . A Release consists of 2 files: - Compressed version of your mod. - JSON text file containing update information.","title":"Uploading Mods"},{"location":"CreatingRelease/#creating-releases","text":"","title":"Creating Releases"},{"location":"CreatingRelease/#from-the-launcher","text":"In order to create a release for a mod, right click the mod and hit Publish in an individual application's main page. Select the Publish Target from the dropdown. (Use Default if your website/location is not present in the list.) Click Publish, and upload the generated .7z files and .json file to the world.","title":"From the Launcher"},{"location":"CreatingRelease/#from-the-commandline","text":"Note If you are making a code mod, it is recommended to use the Publish script from the Mod Template . The following instructions are provided for people wishing to make their own build scripts. Reloaded comes with a set of tools that can be used to create releases outside of the launcher. Reloaded.Publisher.exe [Recommended]: Publishes a release for a mod. Identical features to GUI's Publish Mod menu. NuGetConverter.exe [Legacy]: Automatically creates a NuGet package given a mod folder or a mod zip. You can get them from either of the 2 sources: Via GitHub Releases ( Tools.zip ). Via Chocolatey .","title":"From the Commandline"},{"location":"CreatingRelease/#delta-updates","text":"Reloaded allows for the creation and usage of delta updates. A delta update is an update that only requires the user to download the code and data that has changed instead of the whole mod. If version 1.0.1 adds 8MB worth of files, the user will only need to download 8MB to update from 1.0.0 (instead of e.g. 500MB ) for a big mod. If 1MB out of a 100MB file is changed, the user will only need to download 1MB , not 100MB . To create a delta update, do the following: - Download the previous version of your mod (including .json file!). - Check Automatic Delta in Delta Update tab. - Set Output Folder to the location of the previous update. Note If you have an unpacked version of your previous mod, i.e. as a raw folder; you can add that in the Delta Update tab instead.","title":"Delta Updates"},{"location":"CreatingRelease/#uploading-to-nuget","text":"When creating a release, please select the NuGet publish target. This should output a .nupkg file, which you will upload. The easiest way to upload a package is to install the .NET SDK and use the dotnet commandline utility. Example: # Upload package.nupkg to the official Reloaded server. dotnet nuget push -s http://packages.sewer56.moe:5000/v3/index.json -k API-KEY package.nupkg Upload instructions for the official Reloaded package server .","title":"Uploading to NuGet"},{"location":"DependencyInjection_Consumer/","text":"How to Consume Dependencies Set a Dependency on the Other Mod In your ModConfig.json , update the ModDependencies to include the id of the mod you are consuming. \"ModDependencies\" : [ \"reloaded.sharedlib.hooks\" , \"Riders.Controller.Hook\" ] Add Other Mod's Interfaces Library to your Project Every mod that publishes an interface will have something called an Interfaces library, which contains a collection of all the interfaces that the mod publishes. By convention, this library is usually named <ModId>.Interfaces and comes in the form of a NuGet package, for example: - Reloaded Hooks Shared Lib (NuGet) - Memory SigScan Shared Lib (NuGet) Consume Dependencies Use the IModLoader API to get an instance of the interface you want to consume. This interface should be available at the entry point ( Start ) of the mod you are consuming. WeakReference < Controller > _controller ; void GetController () { _controller = _loader . GetController < IController >(); } \u2705 Always check the controller is valid and hasn't been disposed before usage. void DoSomethingWithController () { // If the mod we got IController from is unloaded, `TryGetTarget` will fail. if ( _controller != null && _controller . TryGetTarget ( out var controller )) { // Do something with `controller` } } Life Cycle & Disposal Info Some Reloaded mods support real-time loading and unloading. As such, you must be careful with how you consume interfaces from other mods. Note You can find out if a mod is unloadable by launching your game and clicking the process in the Processes list in Reloaded. If the unload button is not greyed out, the mod is unloadable. If the mod is not unloadable, you can ignore this section. In order to ensure unloading of publishers can correctly happen in the runtime, Reloaded uses \"Weak References\" ( WeakReference<T> ). Here is guidance on how to use them: \u2705 Storing Weak References on the Heap is OK WeakReference < IController > _reference ; void AcquireController () { _reference = _loader . GetController < IController >(); } \u2705 Storing referenced objects on the Stack is OK void AcquireController () { IController controller = _loader . GetController < IController >(). Target ; // controller is no longer referenced outside of the scope of the method. } \u274c Storing referenced objects on the Heap is NOT OK. IController _controller ; void AcquireController () { _controller = _loader . GetController < IController >(). Target ; // This prevents the mod loader from being unable to dispose the controller. }","title":"2. How to Consume Dependencies"},{"location":"DependencyInjection_Consumer/#how-to-consume-dependencies","text":"","title":"How to Consume Dependencies"},{"location":"DependencyInjection_Consumer/#set-a-dependency-on-the-other-mod","text":"In your ModConfig.json , update the ModDependencies to include the id of the mod you are consuming. \"ModDependencies\" : [ \"reloaded.sharedlib.hooks\" , \"Riders.Controller.Hook\" ]","title":"Set a Dependency on the Other Mod"},{"location":"DependencyInjection_Consumer/#add-other-mods-interfaces-library-to-your-project","text":"Every mod that publishes an interface will have something called an Interfaces library, which contains a collection of all the interfaces that the mod publishes. By convention, this library is usually named <ModId>.Interfaces and comes in the form of a NuGet package, for example: - Reloaded Hooks Shared Lib (NuGet) - Memory SigScan Shared Lib (NuGet)","title":"Add Other Mod's Interfaces Library to your Project"},{"location":"DependencyInjection_Consumer/#consume-dependencies","text":"Use the IModLoader API to get an instance of the interface you want to consume. This interface should be available at the entry point ( Start ) of the mod you are consuming. WeakReference < Controller > _controller ; void GetController () { _controller = _loader . GetController < IController >(); } \u2705 Always check the controller is valid and hasn't been disposed before usage. void DoSomethingWithController () { // If the mod we got IController from is unloaded, `TryGetTarget` will fail. if ( _controller != null && _controller . TryGetTarget ( out var controller )) { // Do something with `controller` } }","title":"Consume Dependencies"},{"location":"DependencyInjection_Consumer/#life-cycle-disposal","text":"Info Some Reloaded mods support real-time loading and unloading. As such, you must be careful with how you consume interfaces from other mods. Note You can find out if a mod is unloadable by launching your game and clicking the process in the Processes list in Reloaded. If the unload button is not greyed out, the mod is unloadable. If the mod is not unloadable, you can ignore this section. In order to ensure unloading of publishers can correctly happen in the runtime, Reloaded uses \"Weak References\" ( WeakReference<T> ). Here is guidance on how to use them: \u2705 Storing Weak References on the Heap is OK WeakReference < IController > _reference ; void AcquireController () { _reference = _loader . GetController < IController >(); } \u2705 Storing referenced objects on the Stack is OK void AcquireController () { IController controller = _loader . GetController < IController >(). Target ; // controller is no longer referenced outside of the scope of the method. } \u274c Storing referenced objects on the Heap is NOT OK. IController _controller ; void AcquireController () { _controller = _loader . GetController < IController >(). Target ; // This prevents the mod loader from being unable to dispose the controller. }","title":"Life Cycle &amp; Disposal"},{"location":"DependencyInjection_ExtraFeatures/","text":"Extra Features Interface Factories Warning This feature has never been battle tested. It's been Reloaded's least used feature since release; no known mod uses this at time of writing. Reloaded's API also provides a functionality to create all instances implementing a type. You can do this through the MakeInterfaces method. // _loader is an instance of IModLoader var interfaces = _loader . MakeInterfaces < ISharedInterface >(); When you run the above code, Reloaded will iterate through every loaded mod and create an instance of every class implementing ISharedInterface . The result of this operation (all instances) will be returned as an array. Optional Dependencies ( OptionalDependencies in ModConfig.json ) Mods can also use the OptionalDependencies field instead of the ModDependencies field. Doing so allows you to consume dependencies from the other package, but does not re-order the mod load order or give any warnings to the user. As such, you should call GetController / MakeInterfaces from the OnModLoaderInitialized event (called when all mods are loaded). IModLoader _loader ; WeakReference < IController > _controller ; void Start ( IModLoaderV1 loader ) { _loader = ( IModLoader ) loader ; _loader . OnModLoaderInitialized += Initialized ; } // Called by the mod loader after all mods finished loading. void Initialized () { _controller = _loader . GetController < IController >(); }","title":"Extra Features"},{"location":"DependencyInjection_ExtraFeatures/#extra-features","text":"","title":"Extra Features"},{"location":"DependencyInjection_ExtraFeatures/#interface-factories","text":"Warning This feature has never been battle tested. It's been Reloaded's least used feature since release; no known mod uses this at time of writing. Reloaded's API also provides a functionality to create all instances implementing a type. You can do this through the MakeInterfaces method. // _loader is an instance of IModLoader var interfaces = _loader . MakeInterfaces < ISharedInterface >(); When you run the above code, Reloaded will iterate through every loaded mod and create an instance of every class implementing ISharedInterface . The result of this operation (all instances) will be returned as an array.","title":"Interface Factories"},{"location":"DependencyInjection_ExtraFeatures/#optional-dependencies","text":"( OptionalDependencies in ModConfig.json ) Mods can also use the OptionalDependencies field instead of the ModDependencies field. Doing so allows you to consume dependencies from the other package, but does not re-order the mod load order or give any warnings to the user. As such, you should call GetController / MakeInterfaces from the OnModLoaderInitialized event (called when all mods are loaded). IModLoader _loader ; WeakReference < IController > _controller ; void Start ( IModLoaderV1 loader ) { _loader = ( IModLoader ) loader ; _loader . OnModLoaderInitialized += Initialized ; } // Called by the mod loader after all mods finished loading. void Initialized () { _controller = _loader . GetController < IController >(); }","title":"Optional Dependencies"},{"location":"DependencyInjection_HowItReallyWork/","text":"How does it Really Work? Info The following section describes the internal implementation detail of how dependency injection works. It is provided to those that are really interested. Reloaded makes extensive use of AssemblyLoadContext (s) to provide isolation between mods, such that they may use 3rd library plugins and dependencies of their choice without interfering with other mods. This can make it difficult to share state between a mod and the loader, and even more so between individual mods. Reloaded overcomes this challenge by sharing instances of Assemblies (DLLs), loosening up isolation around shared code. Mods can nominate which Assemblies they wish to share with other mods, and the loader will load them into a shared AssemblyLoadContext . When the mod is loaded, the Mod Loader will then force it use the shared Assembly instances from the shared AssemblyLoadContext . For publishers its own shared types are automatically shared with itself, for consumers this is determined using the ModDependencies field in ModConfig.json . How is this arrangement Setup? The whole process for sharing an Assembly looks something like this: Gathering Dependencies Mod Loader loads Redirector (Publisher). Mod Loader loads all shared Assemblies into Shared AssemblyLoadContext Mod Loader unloads Redirector (Publisher). Loading Mods Mod Loader loads Redirector , sharing its own Assemblies with itself (from 1.b). Mod Loader loads RedirectorMonitor (Consumer). RedirectorMonitor specified Redirector in its ModDependencies field. Therefore Mod Loader shares all of Redirector 's exports with RedirectorMonitor . Executing Mods Mod Loader rearranges mod load order to account for mod dependencies. Redirector code executes. Redirector publishes IRedirectorController (from Reloaded.Mod.Interfaces.IRedirector.dll) to Mod Loader. Monitor code executes. Monitor obtains IRedirectorController from Mod Loader.","title":"How does it Really Work"},{"location":"DependencyInjection_HowItReallyWork/#how-does-it-really-work","text":"Info The following section describes the internal implementation detail of how dependency injection works. It is provided to those that are really interested. Reloaded makes extensive use of AssemblyLoadContext (s) to provide isolation between mods, such that they may use 3rd library plugins and dependencies of their choice without interfering with other mods. This can make it difficult to share state between a mod and the loader, and even more so between individual mods. Reloaded overcomes this challenge by sharing instances of Assemblies (DLLs), loosening up isolation around shared code. Mods can nominate which Assemblies they wish to share with other mods, and the loader will load them into a shared AssemblyLoadContext . When the mod is loaded, the Mod Loader will then force it use the shared Assembly instances from the shared AssemblyLoadContext . For publishers its own shared types are automatically shared with itself, for consumers this is determined using the ModDependencies field in ModConfig.json .","title":"How does it Really Work?"},{"location":"DependencyInjection_HowItReallyWork/#how-is-this-arrangement-setup","text":"The whole process for sharing an Assembly looks something like this: Gathering Dependencies Mod Loader loads Redirector (Publisher). Mod Loader loads all shared Assemblies into Shared AssemblyLoadContext Mod Loader unloads Redirector (Publisher). Loading Mods Mod Loader loads Redirector , sharing its own Assemblies with itself (from 1.b). Mod Loader loads RedirectorMonitor (Consumer). RedirectorMonitor specified Redirector in its ModDependencies field. Therefore Mod Loader shares all of Redirector 's exports with RedirectorMonitor . Executing Mods Mod Loader rearranges mod load order to account for mod dependencies. Redirector code executes. Redirector publishes IRedirectorController (from Reloaded.Mod.Interfaces.IRedirector.dll) to Mod Loader. Monitor code executes. Monitor obtains IRedirectorController from Mod Loader.","title":"How is this arrangement Setup?"},{"location":"DependencyInjection_HowItWork/","text":"Introduction Sometimes you might want to check the state of another mod, run some code from it and/or instruct another mod to perform a certain action. Reloaded-II provides a mechanism to do this. How Does it Work? Implemented using interfaces, the concept is that the mod loader acts as a middleman between mods (it's a DI container!). This middleman allows mods to communicate by passing implementations of interfaces between each other. This may be illustrated by the following diagram: An example of an external mod communicating with the Universal File Redirector . During initialization, Mod A (Redirector) publishes an interface to the Mod Loader. During initialization, Mod B (Other Mod) asks the Mod Loader for the interface. Communication with the Mod Loader is performed using the IModLoader interface, available at your mod's entry point.","title":"1. How Does it Work?"},{"location":"DependencyInjection_HowItWork/#introduction","text":"Sometimes you might want to check the state of another mod, run some code from it and/or instruct another mod to perform a certain action. Reloaded-II provides a mechanism to do this.","title":"Introduction"},{"location":"DependencyInjection_HowItWork/#how-does-it-work","text":"Implemented using interfaces, the concept is that the mod loader acts as a middleman between mods (it's a DI container!). This middleman allows mods to communicate by passing implementations of interfaces between each other. This may be illustrated by the following diagram: An example of an external mod communicating with the Universal File Redirector . During initialization, Mod A (Redirector) publishes an interface to the Mod Loader. During initialization, Mod B (Other Mod) asks the Mod Loader for the interface. Communication with the Mod Loader is performed using the IModLoader interface, available at your mod's entry point.","title":"How Does it Work?"},{"location":"DependencyInjection_Publisher/","text":"How to Publish Dependencies Publishing dependencies in Reloaded is done through something called Interfaces libraries. Interfaces libraries are simply libraries that contain a collection of all interfaces a mod wants to make public. Create an Interfaces Library Create a separate Class Library project in your solution named, <YOUR_MOD_ID>.Interfaces (by convention). Add a Project Reference from to this new library in your main mod. Your Solution Explorer (or equivalent) should look something like this: Create a NuGet Package Info Please note, that once you upload a package to NuGet.org, you cannot delete it, only hide it from search results. To make your interfaces library more accessible, it is preferable to make it a NuGet package and publish it to NuGet.org. To do so, add and fill the following lines to your interface project's .csproj file (inside the first PropertyGroup ): <!-- Create NuGet Package and include your Documentation/comments inside. --> <GenerateDocumentationFile> true </GenerateDocumentationFile> <GeneratePackageOnBuild> True </GeneratePackageOnBuild> <!-- Set to the same as your project name/namespace --> <PackageId> Your.Namespace.Here.Interfaces </PackageId> <!-- Use Semantic Versioning --> <Version> 1.0.0 </Version> <Authors> YourNameHere </Authors> <!-- Description of your Package --> <Description> Description of your mod. </Description> <!-- Link to your Source Code [GitHub Page, etc.] --> <PackageProjectUrl></PackageProjectUrl> <RepositoryUrl></RepositoryUrl> <!-- URL to the icon seen for your package in NuGet Search --> <PackageIconUrl> https://avatars1.githubusercontent.com/u/45473408 </PackageIconUrl> <!-- SPDX License Identifier: https://spdx.org/licenses/ --> <PackageLicenseExpression> LGPL-3.0-or-later </PackageLicenseExpression> <PackageRequireLicenseAcceptance> True </PackageRequireLicenseAcceptance> Then build the project in Release mode. When you build the interfaces project, you should now see an accompanying .nupkg file in the bin folder. You can then upload this file to NuGet.org. Note If you are using an IDE like Visual Studio, you'll most likely be able to edit these properties from a Properties / Project Settings window. Create Interfaces Create the interfaces for each of the public APIs that you wish to expose to other mods. A quick way to do this (in many IDEs) is to hover your text cursor over a class name and apply the Extract Interface Quick Fix/option. An example interface: /// <summary> /// Represents an individual scanner that can be used to scan for byte patterns. /// </summary> public interface IScanner : IDisposable { /// <summary> /// Attempts to find a given pattern inside the memory region this class was created with. /// The method used depends on the available hardware; will use vectorized instructions if available. /// </summary> /// <param name=\"pattern\"> /// The pattern to look for inside the given region. /// Example: \"11 22 33 ?? 55\". /// Key: ?? represents a byte that should be ignored, anything else if a hex byte. i.e. 11 represents 0x11, 1F represents 0x1F /// </param> /// <returns>A result indicating an offset (if found) of the pattern.</returns> PatternScanResult FindPattern ( string pattern ); } Danger Your interfaces library SHOULD NOT contain any external references/NuGet packages/3rd party libraries. You risk breaking others' mods if they end up using the same libraries. Publish the Interfaces Library All that's left is for you to publish the interfaces library. To do this, two steps are required. Export the Interfaces Create a class which inherits from IExports . In GetTypes , return an array of interfaces to be consumed by other mods. public class Exports : IExports { // Sharing a type actually exports the whole library. // So you only really need to share 1 type to export your whole interfaces library. public Type [] GetTypes () => new [] { typeof ( IController ) }; } Share it with Mod Loader During initialization ( Start() ), register your interface with the Mod Loader using the IModLoader instance. void PublishInterface () { var _controller = new Controller (); // Implements IController _loader . AddOrReplaceController < IController >( this , _controller ); } Disposing (Publisher) Reloaded will automatically dispose your dependencies when your mod is unloaded. You can however, still manually (if desired) dispose/replace your dependency instances with the RemoveController method. void Unload () { _loader . RemoveController < IController >(); } Upgrading Interfaces Tip This Microsoft Code Analyzer is very highly recommended. When combined with source control, e.g. 'git' it will help you keep track of the APIs your mod exposes. You are free to ADD anything to your existing interfaces at any time. However, after you publish an interface, you should NEVER : - Remove any parts of it. - Change any existing parts of it (names, parameters). Failure to do so will break any mods which use those methods. Examples The following mods can be used as examples. Universal Mods Reloaded Universal File Redirector Producer: Reloaded.Universal.Redirector Contract: Reloaded.Universal.Redirector.Interfaces Consumer(s): Reloaded.Universal.Monitor , Reloaded.Universal.RedirectorMonitor Application Specific Sonic Heroes Controller Hook (Allows other mods to receive/send game inputs.) Producer: Riders.Controller.Hook Contract: Riders.Controller.Hook.Interfaces Consumer(s): Riders.Controller.Hook.Custom , Riders.Controller.Hook.XInput , Riders.Controller.Hook.PostProcess Sonic Riders Controller Hook (Allows other mods to receive/send game inputs.) Producer: Heroes.Controller.Hook Contract: Heroes.Controller.Hook.Interfaces Consumer(s): Heroes.Controller.Hook.Custom , Heroes.Controller.Hook.XInput , Heroes.Controller.Hook.PostProcess Libraries as Dependencies PRS Compressor/Decompressor Reloaded.Hooks (Function Hooking/Detour Library)","title":"3. How to Publish Dependencies"},{"location":"DependencyInjection_Publisher/#how-to-publish-dependencies","text":"Publishing dependencies in Reloaded is done through something called Interfaces libraries. Interfaces libraries are simply libraries that contain a collection of all interfaces a mod wants to make public.","title":"How to Publish Dependencies"},{"location":"DependencyInjection_Publisher/#create-an-interfaces-library","text":"Create a separate Class Library project in your solution named, <YOUR_MOD_ID>.Interfaces (by convention). Add a Project Reference from to this new library in your main mod. Your Solution Explorer (or equivalent) should look something like this:","title":"Create an Interfaces Library"},{"location":"DependencyInjection_Publisher/#create-a-nuget-package","text":"Info Please note, that once you upload a package to NuGet.org, you cannot delete it, only hide it from search results. To make your interfaces library more accessible, it is preferable to make it a NuGet package and publish it to NuGet.org. To do so, add and fill the following lines to your interface project's .csproj file (inside the first PropertyGroup ): <!-- Create NuGet Package and include your Documentation/comments inside. --> <GenerateDocumentationFile> true </GenerateDocumentationFile> <GeneratePackageOnBuild> True </GeneratePackageOnBuild> <!-- Set to the same as your project name/namespace --> <PackageId> Your.Namespace.Here.Interfaces </PackageId> <!-- Use Semantic Versioning --> <Version> 1.0.0 </Version> <Authors> YourNameHere </Authors> <!-- Description of your Package --> <Description> Description of your mod. </Description> <!-- Link to your Source Code [GitHub Page, etc.] --> <PackageProjectUrl></PackageProjectUrl> <RepositoryUrl></RepositoryUrl> <!-- URL to the icon seen for your package in NuGet Search --> <PackageIconUrl> https://avatars1.githubusercontent.com/u/45473408 </PackageIconUrl> <!-- SPDX License Identifier: https://spdx.org/licenses/ --> <PackageLicenseExpression> LGPL-3.0-or-later </PackageLicenseExpression> <PackageRequireLicenseAcceptance> True </PackageRequireLicenseAcceptance> Then build the project in Release mode. When you build the interfaces project, you should now see an accompanying .nupkg file in the bin folder. You can then upload this file to NuGet.org. Note If you are using an IDE like Visual Studio, you'll most likely be able to edit these properties from a Properties / Project Settings window.","title":"Create a NuGet Package"},{"location":"DependencyInjection_Publisher/#create-interfaces","text":"Create the interfaces for each of the public APIs that you wish to expose to other mods. A quick way to do this (in many IDEs) is to hover your text cursor over a class name and apply the Extract Interface Quick Fix/option. An example interface: /// <summary> /// Represents an individual scanner that can be used to scan for byte patterns. /// </summary> public interface IScanner : IDisposable { /// <summary> /// Attempts to find a given pattern inside the memory region this class was created with. /// The method used depends on the available hardware; will use vectorized instructions if available. /// </summary> /// <param name=\"pattern\"> /// The pattern to look for inside the given region. /// Example: \"11 22 33 ?? 55\". /// Key: ?? represents a byte that should be ignored, anything else if a hex byte. i.e. 11 represents 0x11, 1F represents 0x1F /// </param> /// <returns>A result indicating an offset (if found) of the pattern.</returns> PatternScanResult FindPattern ( string pattern ); } Danger Your interfaces library SHOULD NOT contain any external references/NuGet packages/3rd party libraries. You risk breaking others' mods if they end up using the same libraries.","title":"Create Interfaces"},{"location":"DependencyInjection_Publisher/#publish-the-interfaces-library","text":"All that's left is for you to publish the interfaces library. To do this, two steps are required.","title":"Publish the Interfaces Library"},{"location":"DependencyInjection_Publisher/#export-the-interfaces","text":"Create a class which inherits from IExports . In GetTypes , return an array of interfaces to be consumed by other mods. public class Exports : IExports { // Sharing a type actually exports the whole library. // So you only really need to share 1 type to export your whole interfaces library. public Type [] GetTypes () => new [] { typeof ( IController ) }; }","title":"Export the Interfaces"},{"location":"DependencyInjection_Publisher/#share-it-with-mod-loader","text":"During initialization ( Start() ), register your interface with the Mod Loader using the IModLoader instance. void PublishInterface () { var _controller = new Controller (); // Implements IController _loader . AddOrReplaceController < IController >( this , _controller ); }","title":"Share it with Mod Loader"},{"location":"DependencyInjection_Publisher/#disposing-publisher","text":"Reloaded will automatically dispose your dependencies when your mod is unloaded. You can however, still manually (if desired) dispose/replace your dependency instances with the RemoveController method. void Unload () { _loader . RemoveController < IController >(); }","title":"Disposing (Publisher)"},{"location":"DependencyInjection_Publisher/#upgrading-interfaces","text":"Tip This Microsoft Code Analyzer is very highly recommended. When combined with source control, e.g. 'git' it will help you keep track of the APIs your mod exposes. You are free to ADD anything to your existing interfaces at any time. However, after you publish an interface, you should NEVER : - Remove any parts of it. - Change any existing parts of it (names, parameters). Failure to do so will break any mods which use those methods.","title":"Upgrading Interfaces"},{"location":"DependencyInjection_Publisher/#examples","text":"The following mods can be used as examples. Universal Mods Reloaded Universal File Redirector Producer: Reloaded.Universal.Redirector Contract: Reloaded.Universal.Redirector.Interfaces Consumer(s): Reloaded.Universal.Monitor , Reloaded.Universal.RedirectorMonitor Application Specific Sonic Heroes Controller Hook (Allows other mods to receive/send game inputs.) Producer: Riders.Controller.Hook Contract: Riders.Controller.Hook.Interfaces Consumer(s): Riders.Controller.Hook.Custom , Riders.Controller.Hook.XInput , Riders.Controller.Hook.PostProcess Sonic Riders Controller Hook (Allows other mods to receive/send game inputs.) Producer: Heroes.Controller.Hook Contract: Heroes.Controller.Hook.Interfaces Consumer(s): Heroes.Controller.Hook.Custom , Heroes.Controller.Hook.XInput , Heroes.Controller.Hook.PostProcess Libraries as Dependencies PRS Compressor/Decompressor Reloaded.Hooks (Function Hooking/Detour Library)","title":"Examples"},{"location":"DevelopmentEnvironmentSetup/","text":"Development Environment Setup To start developing mods with Reloaded, you will need the following: Latest .NET SDK Integrated Development Environment (IDE) Reloaded Mod Template More details below. You should also run Reloaded at least once before starting to develop mods. .NET SDK To install .NET SDK, do the following: - Visit .NET Download Page . - Download and Install the Latest .NET SDK for your OS. To verify that the SDK is correctly installed, open up a command prompt and run the following command: dotnet --list-sdks Assuming the SDK is installed correctly, the command should return at least 1 entry and its location. Example output: 6.0.300 [C:\\Program Files\\dotnet\\sdk] Integrated Development Environment (IDE) The most common IDEs and code editors used with .NET include the following: Visual Studio Community : Free. The .NET IDE pretty much everyone is familiar with. Windows only. JetBrains Rider : Paid. Good choice for those familiar with other JetBrains products like IntelliJ and PyCharm. Crossplatform. Visual Studio Code : Free. Crossplatform, supports .NET via plugins. Note: At this current moment in time (2022), Visual Studio is the suggested code editor since it is the only one that can be used for debugging Reloaded mods at this time. This will hopefully change in the future. Installing Reloaded Mod Template Reloaded provides a template to allow for a quick start with mod development. To install the template, run the following command: dotnet new -i Reloaded.Mod.Templates Once installation is complete, you should see a dialog that looks like this upon success: Template Name Short Name Language Tags ------------------------ ---------- -------- -------------------- Reloaded II Mod Template reloaded [C#] Common/Library/Games Summary You are now ready to start developing mods with Reloaded. Next: Creating a New Project","title":"1. Setting Up Development Environment"},{"location":"DevelopmentEnvironmentSetup/#development-environment-setup","text":"To start developing mods with Reloaded, you will need the following: Latest .NET SDK Integrated Development Environment (IDE) Reloaded Mod Template More details below. You should also run Reloaded at least once before starting to develop mods.","title":"Development Environment Setup"},{"location":"DevelopmentEnvironmentSetup/#net-sdk","text":"To install .NET SDK, do the following: - Visit .NET Download Page . - Download and Install the Latest .NET SDK for your OS. To verify that the SDK is correctly installed, open up a command prompt and run the following command: dotnet --list-sdks Assuming the SDK is installed correctly, the command should return at least 1 entry and its location. Example output: 6.0.300 [C:\\Program Files\\dotnet\\sdk]","title":".NET SDK"},{"location":"DevelopmentEnvironmentSetup/#integrated-development-environment-ide","text":"The most common IDEs and code editors used with .NET include the following: Visual Studio Community : Free. The .NET IDE pretty much everyone is familiar with. Windows only. JetBrains Rider : Paid. Good choice for those familiar with other JetBrains products like IntelliJ and PyCharm. Crossplatform. Visual Studio Code : Free. Crossplatform, supports .NET via plugins. Note: At this current moment in time (2022), Visual Studio is the suggested code editor since it is the only one that can be used for debugging Reloaded mods at this time. This will hopefully change in the future.","title":"Integrated Development Environment (IDE)"},{"location":"DevelopmentEnvironmentSetup/#installing-reloaded-mod-template","text":"Reloaded provides a template to allow for a quick start with mod development. To install the template, run the following command: dotnet new -i Reloaded.Mod.Templates Once installation is complete, you should see a dialog that looks like this upon success: Template Name Short Name Language Tags ------------------------ ---------- -------- -------------------- Reloaded II Mod Template reloaded [C#] Common/Library/Games","title":"Installing Reloaded Mod Template"},{"location":"DevelopmentEnvironmentSetup/#summary","text":"You are now ready to start developing mods with Reloaded. Next: Creating a New Project","title":"Summary"},{"location":"EnablingUpdateSupport/","text":"Adding Update Support Reloaded mods use Semantic Versioning 2.0 as the standard for version names. Please use the X.Y.Z format for your mod versions, and/or any other format supported by semantic versioning. Enabling Update Support In modern Reloaded, configurations for updates are part of the mod metadata ModConfig.json . These configurations can be easily edited using the Edit Mod Menu . You can find this menu in either - Manage Mods -> Highlight Mod -> Edit Mod or - Game -> Right Click Mod -> Edit Mod Hover your mouse over the text boxes for more information. Pre-releases are also supported, but must be explicitly enabled by the user ( Edit User Config -> Allow Beta Versions ). GameBanana To support updates from GameBanana, first upload your mod as a private submission Then copy the item ID from the URL of your mod page: Insert the number from the URL into the ItemID field in the mod configuration, and you are done. If you are publishing the mod from the GUI, please select the GameBanana option in the dropdown. GitHub Releases For GitHub Releases, tags are used to denote the current version of your mod: If the GitHub tag version is higher than the local one, there is an update. If you wish not to use tags [e.g. you have multiple mods in single GitHub Release], uncheck the UseReleaseTags box. NuGet For NuGet, you should specify the URL of the NuGet V3 server index where the mod should receive updates from. Any NuGet V3 feed is supported. Most common feed is the official Reloaded NuGet Package Server http://packages.sewer56.moe:5000/v3/index.json as it preconfigured in Reloaded's Launcher out of the box. To add a server, right click the empty space beside DefaultRepositoryUrls and press Add , then click the newly created textbox to add an URL. Publishing Multiple Mods Note This section applies to mods made before June 2022. Mods created using updated template or launcher should need no changes. In some scenarios you might want to prefer to publish multiple mods to a single GameBanana or GitHub page. In order to do this, you will need to rename the Release Metadata file in the Edit Mod menu such no 2 mods you will publish to the same page will use the same name. Summary Your mod should be ready for receiving in-launcher updates now. Next: Creating a Release","title":"1. Enabling Update Support"},{"location":"EnablingUpdateSupport/#adding-update-support","text":"Reloaded mods use Semantic Versioning 2.0 as the standard for version names. Please use the X.Y.Z format for your mod versions, and/or any other format supported by semantic versioning.","title":"Adding Update Support"},{"location":"EnablingUpdateSupport/#enabling-update-support","text":"In modern Reloaded, configurations for updates are part of the mod metadata ModConfig.json . These configurations can be easily edited using the Edit Mod Menu . You can find this menu in either - Manage Mods -> Highlight Mod -> Edit Mod or - Game -> Right Click Mod -> Edit Mod Hover your mouse over the text boxes for more information. Pre-releases are also supported, but must be explicitly enabled by the user ( Edit User Config -> Allow Beta Versions ).","title":"Enabling Update Support"},{"location":"EnablingUpdateSupport/#gamebanana","text":"To support updates from GameBanana, first upload your mod as a private submission Then copy the item ID from the URL of your mod page: Insert the number from the URL into the ItemID field in the mod configuration, and you are done. If you are publishing the mod from the GUI, please select the GameBanana option in the dropdown.","title":"GameBanana"},{"location":"EnablingUpdateSupport/#github-releases","text":"For GitHub Releases, tags are used to denote the current version of your mod: If the GitHub tag version is higher than the local one, there is an update. If you wish not to use tags [e.g. you have multiple mods in single GitHub Release], uncheck the UseReleaseTags box.","title":"GitHub Releases"},{"location":"EnablingUpdateSupport/#nuget","text":"For NuGet, you should specify the URL of the NuGet V3 server index where the mod should receive updates from. Any NuGet V3 feed is supported. Most common feed is the official Reloaded NuGet Package Server http://packages.sewer56.moe:5000/v3/index.json as it preconfigured in Reloaded's Launcher out of the box. To add a server, right click the empty space beside DefaultRepositoryUrls and press Add , then click the newly created textbox to add an URL.","title":"NuGet"},{"location":"EnablingUpdateSupport/#publishing-multiple-mods","text":"Note This section applies to mods made before June 2022. Mods created using updated template or launcher should need no changes. In some scenarios you might want to prefer to publish multiple mods to a single GameBanana or GitHub page. In order to do this, you will need to rename the Release Metadata file in the Edit Mod menu such no 2 mods you will publish to the same page will use the same name.","title":"Publishing Multiple Mods"},{"location":"EnablingUpdateSupport/#summary","text":"Your mod should be ready for receiving in-launcher updates now. Next: Creating a Release","title":"Summary"},{"location":"ExperimentalFeatures/","text":"Experimental & Miscellaneous Features This page lists Reloaded features which don't necessarily fit into other pages of the wiki. Experimental Features Experimental features are features which are either partially implemented, or which have not yet been thoroughly tested. Use at your own risk. Portable Mode Reloaded II can be put into portable mode by creating a file called portable.txt in the same directory as the launcher. When portable mode is used, Reloaded will always use the Apps , Mods , User and Plugins folders from the launcher's directory. Other global settings still apply, however. Relative Pathed Applications It's possible to set a relative AppLocation for programs, as opposed to a fixed path. This will allow you to move the launcher to a subfolder of a game should you plan to only use Reloaded with one game, or ship the launcher preconfigured for a given game. Example Configuration ( Apps/sonicriders.exe/AppConfig.json ): // `Reloaded II/Apps/so n icriders.exe` - > `So n ic Riders/So n icRiders.exe` { \"AppId\" : \"sonicriders.exe\" , \"AppName\" : \"Sonic Riders\" , \"AppLocation\" : \"..\\\\..\\\\..\\\\Sonic Riders\\\\SonicRiders.exe\" , \"AppArguments\" : \"\" , \"AppIcon\" : \"Icon.png\" , \"AutoInject\" : false } All paths are relative to the folder in which the AppConfig.json file is located. Miscellaneous Features RGB Window Border You can set your window border to hue cycle through the colors of the rainbow. This is a hidden feature that can be used in themes, and is set in Theme/Default/Settings.xaml . Property name is EnableGlowHueCycle .","title":"Misc & Experimental Features"},{"location":"ExperimentalFeatures/#experimental-miscellaneous-features","text":"This page lists Reloaded features which don't necessarily fit into other pages of the wiki.","title":"Experimental &amp; Miscellaneous Features"},{"location":"ExperimentalFeatures/#experimental-features","text":"Experimental features are features which are either partially implemented, or which have not yet been thoroughly tested. Use at your own risk.","title":"Experimental Features"},{"location":"ExperimentalFeatures/#portable-mode","text":"Reloaded II can be put into portable mode by creating a file called portable.txt in the same directory as the launcher. When portable mode is used, Reloaded will always use the Apps , Mods , User and Plugins folders from the launcher's directory. Other global settings still apply, however.","title":"Portable Mode"},{"location":"ExperimentalFeatures/#relative-pathed-applications","text":"It's possible to set a relative AppLocation for programs, as opposed to a fixed path. This will allow you to move the launcher to a subfolder of a game should you plan to only use Reloaded with one game, or ship the launcher preconfigured for a given game. Example Configuration ( Apps/sonicriders.exe/AppConfig.json ): // `Reloaded II/Apps/so n icriders.exe` - > `So n ic Riders/So n icRiders.exe` { \"AppId\" : \"sonicriders.exe\" , \"AppName\" : \"Sonic Riders\" , \"AppLocation\" : \"..\\\\..\\\\..\\\\Sonic Riders\\\\SonicRiders.exe\" , \"AppArguments\" : \"\" , \"AppIcon\" : \"Icon.png\" , \"AutoInject\" : false } All paths are relative to the folder in which the AppConfig.json file is located.","title":"Relative Pathed Applications"},{"location":"ExperimentalFeatures/#miscellaneous-features","text":"","title":"Miscellaneous Features"},{"location":"ExperimentalFeatures/#rgb-window-border","text":"You can set your window border to hue cycle through the colors of the rainbow. This is a hidden feature that can be used in themes, and is set in Theme/Default/Settings.xaml . Property name is EnableGlowHueCycle .","title":"RGB Window Border"},{"location":"FAQ/","text":"Frequently Asked Questions What are the official download links for Reloaded? The official downloads for Reloaded-II are on: GitHub https://github.com/Reloaded-Project/Reloaded-II/releases GameBanana https://gamebanana.com/tools/6693 Anything else is unofficial. GitHub is always kept up to date while GameBanana is sometimes updated slightly less periodically. Regardless of what you download, the launcher will always offer to update itself to the latest up to date version. Reloaded doesn't boot, what should I do? Have you installed the dependencies? No, seriously, 99% of the time it's just that. Please look directly above the download button on both GameBanana and GitHub and download ALL of the linked dependencies. How do I get started with using Reloaded? It's as easy as 1,2,3. Take a look at the quick start guide! How do I report issues with Reloaded? Please use the following link: https://github.com/Reloaded-Project/Reloaded-II/issues Can I use Reloaded with Steam Overlay/Controller Support? There are multiple ways to do so, but the two recommended ones are: Add Reloaded Shortcut to Steam Load Reloaded via a DLL replacement based code loader (e.g. Ultimate ASI Loader) For the first option, simply create a shortcut from within the Reloaded launcher and add it to Steam, then copy the Target from your shortcut properties into Steam's own Target field. The second option can now also be automated from the launcher, by expanding the Advanced section of Add/Edit Application Menu . Simply press the Deploy ASI Loader button and voila! My controller does not work when using Reloaded You're probably using an old style controller with a game that only supports Xbox-style (XInput) controllers. Please see issues/38 for more details and workarounds. Can I use Reloaded with Multiplayer Games? Please don't, this isn't what Reloaded was built for and you'll most likely get banned if the game has a decent anticheat. How do I get started with making mods for Reloaded? Getting started with making mods is very easy, you can in fact do it from inside the launcher itself! Follow this guide for an explanation of things . Before you get going, reach out and consult the community for your application! If they are already using Reloaded, they may have some fancy mods, tools, or both! How do I get started with programming mods for Reloaded? As a programmer you should have an adequate level of self sufficiency. As such, please follow the following guide: Building Mods Documentation for two of the most commonly used libraries (they are part of the template!) can be found in the following places: Reloaded.Memory Reloaded.Hooks How can I contribute to Reloaded? The easiest way to contribute to Reloaded is to look at the issue list on GitHub . Anything labelled as accepted is up for grabs by anyone, unless assigned to a specific user. Just make sure to follow the coding style in the existing projects and try to write good code. If the code isn't up to scruff, you might be asked to make changes. Instructions for building Reloaded, and some of the details of its internal workings are also available as part of the documentation Documentation, especially one that benefits the end user is just as valuable as any code. I'm from a C/C++ background? Is there any way we can transfer our existing work? Reloaded CAN load native DLLs, albeit with limited support. For more details please see: Native Mods If your mod was written with an ASI Loader in mind, it should work out of the box. If your existing mod is tied with a specific mod loader (e.g. using some kind of loader API), you will need to find a way to replace this functionality. Please note that config files may be dropped in game directory for mods originally meant for ASI loaders, unless the mod explicitly checks DLL directory; you might need to make minor changes to your mods to account for that. You will still need to generate a mod configuration as per the guide.","title":"Frequently Asked Questions"},{"location":"FAQ/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"FAQ/#what-are-the-official-download-links-for-reloaded","text":"The official downloads for Reloaded-II are on: GitHub https://github.com/Reloaded-Project/Reloaded-II/releases GameBanana https://gamebanana.com/tools/6693 Anything else is unofficial. GitHub is always kept up to date while GameBanana is sometimes updated slightly less periodically. Regardless of what you download, the launcher will always offer to update itself to the latest up to date version.","title":"What are the official download links for Reloaded?"},{"location":"FAQ/#reloaded-doesnt-boot-what-should-i-do","text":"Have you installed the dependencies? No, seriously, 99% of the time it's just that. Please look directly above the download button on both GameBanana and GitHub and download ALL of the linked dependencies.","title":"Reloaded doesn't boot, what should I do?"},{"location":"FAQ/#how-do-i-get-started-with-using-reloaded","text":"It's as easy as 1,2,3. Take a look at the quick start guide!","title":"How do I get started with using Reloaded?"},{"location":"FAQ/#how-do-i-report-issues-with-reloaded","text":"Please use the following link: https://github.com/Reloaded-Project/Reloaded-II/issues","title":"How do I report issues with Reloaded?"},{"location":"FAQ/#can-i-use-reloaded-with-steam-overlaycontroller-support","text":"There are multiple ways to do so, but the two recommended ones are: Add Reloaded Shortcut to Steam Load Reloaded via a DLL replacement based code loader (e.g. Ultimate ASI Loader) For the first option, simply create a shortcut from within the Reloaded launcher and add it to Steam, then copy the Target from your shortcut properties into Steam's own Target field. The second option can now also be automated from the launcher, by expanding the Advanced section of Add/Edit Application Menu . Simply press the Deploy ASI Loader button and voila!","title":"Can I use Reloaded with Steam Overlay/Controller Support?"},{"location":"FAQ/#my-controller-does-not-work-when-using-reloaded","text":"You're probably using an old style controller with a game that only supports Xbox-style (XInput) controllers. Please see issues/38 for more details and workarounds.","title":"My controller does not work when using Reloaded"},{"location":"FAQ/#can-i-use-reloaded-with-multiplayer-games","text":"Please don't, this isn't what Reloaded was built for and you'll most likely get banned if the game has a decent anticheat.","title":"Can I use Reloaded with Multiplayer Games?"},{"location":"FAQ/#how-do-i-get-started-with-making-mods-for-reloaded","text":"Getting started with making mods is very easy, you can in fact do it from inside the launcher itself! Follow this guide for an explanation of things . Before you get going, reach out and consult the community for your application! If they are already using Reloaded, they may have some fancy mods, tools, or both!","title":"How do I get started with making mods for Reloaded?"},{"location":"FAQ/#how-do-i-get-started-with-programming-mods-for-reloaded","text":"As a programmer you should have an adequate level of self sufficiency. As such, please follow the following guide: Building Mods Documentation for two of the most commonly used libraries (they are part of the template!) can be found in the following places: Reloaded.Memory Reloaded.Hooks","title":"How do I get started with programming mods for Reloaded?"},{"location":"FAQ/#how-can-i-contribute-to-reloaded","text":"The easiest way to contribute to Reloaded is to look at the issue list on GitHub . Anything labelled as accepted is up for grabs by anyone, unless assigned to a specific user. Just make sure to follow the coding style in the existing projects and try to write good code. If the code isn't up to scruff, you might be asked to make changes. Instructions for building Reloaded, and some of the details of its internal workings are also available as part of the documentation Documentation, especially one that benefits the end user is just as valuable as any code.","title":"How can I contribute to Reloaded?"},{"location":"FAQ/#im-from-a-cc-background-is-there-any-way-we-can-transfer-our-existing-work","text":"Reloaded CAN load native DLLs, albeit with limited support. For more details please see: Native Mods If your mod was written with an ASI Loader in mind, it should work out of the box. If your existing mod is tied with a specific mod loader (e.g. using some kind of loader API), you will need to find a way to replace this functionality. Please note that config files may be dropped in game directory for mods originally meant for ASI loaders, unless the mod explicitly checks DLL directory; you might need to make minor changes to your mods to account for that. You will still need to generate a mod configuration as per the guide.","title":"I'm from a C/C++ background? Is there any way we can transfer our existing work?"},{"location":"InjectionMethods/","text":"Introduction There are many ways of loading Reloaded into a specific application or process. Four are officially supported, and can be categorized as both Synchronous and Asynchronous with program startup. Synchronous methods are recommended and allow for all of the mods to be initialized before the game or application starts to execute any code. Asynchronous methods meanwhile load mods as the program is executing. That said some complex mods might not function as expected if loaded asynchronously. Manual Launch (Synchronous) Summary: Reloaded launches the application in a paused/suspended state. Reloaded is then loaded into the suspended application. The application is resumed. Auto-Inject/Inject (Asynchronous) To access this menu, simply click the game instance under the \"other instances\" tab. The \"Inject\" feature simply loads Reloaded into an existing process without having the need to restart it. Auto-inject can be found inside the Add an Application menu, under Advanced Tools & Options . Auto-inject basically automatically injects Reloaded into programs as soon as they are launched. DLL Loader Reloaded can be integrated into other ASI/DLL based mod loaders such as Ultimate-ASI-Loader , by copying the bootstrapper . The bootstrapper is just a special DLL that loads .NET Core into an application and then boots Reloaded. There are two bootstrappers , one for 64-bit and one for 32-bit applications, and they can be found under the Loader/X86/Bootstrapper and Loader/X64/Bootstrapper directories respectively. Installation will depend on the mod loader, but simply put if you copy the contents of this folder and make a mod loader mod, with Reloaded.Mod.Loader.Bootstrapper.dll as the target DLL (if possible), you can load Reloaded in other loaders. Synchronous Loading By default, the bootstrapper DLL will load the mods asynchronously , meaning that they will be initialized as the game is normally running. The bootstrapper however does have a feature to allow loading \"synchronously\" , by killing the game process and rebooting it. The way it works is that the bootstrapper will silently launch the launcher with a set of commandline arguments which instruct the launcher to re-launch the game, effectively performing the Manual Launch launch method. To enable synchronous loading, simply make an empty file called ReloadedPortable.txt in the same directory as the bootstrapper, as seen in the example above. Notes: The launcher will not add any additional commandline arguments, regardless of what you may have set for the application profile. Commandline arguments set in launcher apply to launching from launcher only. Reloaded can and will only be loaded once, the bootstrapper has a safety mechanism to ensure that. Integration Examples Ultimate ASI Loader With Ultimate ASI Loader, you can place the Bootstrapper in your scripts/plugins directory and rename the bootstrapper DLL with an .asi extension. Booting via Ultimate ASI Loader is recommended in games where the embedded Steam DRM \"Steam Stub\" is present (game code is encrypted) as Reloaded II itself does not have a mechanism to handle this DRM. If you are using Ultimate ASI Loader to bypass Steam Stub, you should launch the game using its regular executable as opposed to using the launcher. As of Reloaded II 1.1.0 and above users should not add ReloadedPortable.txt . Reloaded II provides the InitializeASI export, integrating with this loader. NOTE You can install Ultimate ASI Loader to a game from within Reloaded. Please see Edit Application -> Advanced Tools & Options -> Deploy ASI Loader inside the launcher. SADX, SA2, Sonic R, Mania, SKC Mod Loader Mod.ini Name=Reloaded Mod Loader II Author=Sewer56 DLLFile=Reloaded.Mod.Loader.Bootstrapper.dll","title":"Injection Methods"},{"location":"InjectionMethods/#introduction","text":"There are many ways of loading Reloaded into a specific application or process. Four are officially supported, and can be categorized as both Synchronous and Asynchronous with program startup. Synchronous methods are recommended and allow for all of the mods to be initialized before the game or application starts to execute any code. Asynchronous methods meanwhile load mods as the program is executing. That said some complex mods might not function as expected if loaded asynchronously.","title":"Introduction"},{"location":"InjectionMethods/#manual-launch-synchronous","text":"Summary: Reloaded launches the application in a paused/suspended state. Reloaded is then loaded into the suspended application. The application is resumed.","title":"Manual Launch (Synchronous)"},{"location":"InjectionMethods/#auto-injectinject-asynchronous","text":"To access this menu, simply click the game instance under the \"other instances\" tab. The \"Inject\" feature simply loads Reloaded into an existing process without having the need to restart it. Auto-inject can be found inside the Add an Application menu, under Advanced Tools & Options . Auto-inject basically automatically injects Reloaded into programs as soon as they are launched.","title":"Auto-Inject/Inject (Asynchronous)"},{"location":"InjectionMethods/#dll-loader","text":"Reloaded can be integrated into other ASI/DLL based mod loaders such as Ultimate-ASI-Loader , by copying the bootstrapper . The bootstrapper is just a special DLL that loads .NET Core into an application and then boots Reloaded. There are two bootstrappers , one for 64-bit and one for 32-bit applications, and they can be found under the Loader/X86/Bootstrapper and Loader/X64/Bootstrapper directories respectively. Installation will depend on the mod loader, but simply put if you copy the contents of this folder and make a mod loader mod, with Reloaded.Mod.Loader.Bootstrapper.dll as the target DLL (if possible), you can load Reloaded in other loaders.","title":"DLL Loader"},{"location":"InjectionMethods/#synchronous-loading","text":"By default, the bootstrapper DLL will load the mods asynchronously , meaning that they will be initialized as the game is normally running. The bootstrapper however does have a feature to allow loading \"synchronously\" , by killing the game process and rebooting it. The way it works is that the bootstrapper will silently launch the launcher with a set of commandline arguments which instruct the launcher to re-launch the game, effectively performing the Manual Launch launch method. To enable synchronous loading, simply make an empty file called ReloadedPortable.txt in the same directory as the bootstrapper, as seen in the example above. Notes: The launcher will not add any additional commandline arguments, regardless of what you may have set for the application profile. Commandline arguments set in launcher apply to launching from launcher only. Reloaded can and will only be loaded once, the bootstrapper has a safety mechanism to ensure that.","title":"Synchronous Loading"},{"location":"InjectionMethods/#integration-examples","text":"","title":"Integration Examples"},{"location":"InjectionMethods/#ultimate-asi-loader","text":"With Ultimate ASI Loader, you can place the Bootstrapper in your scripts/plugins directory and rename the bootstrapper DLL with an .asi extension. Booting via Ultimate ASI Loader is recommended in games where the embedded Steam DRM \"Steam Stub\" is present (game code is encrypted) as Reloaded II itself does not have a mechanism to handle this DRM. If you are using Ultimate ASI Loader to bypass Steam Stub, you should launch the game using its regular executable as opposed to using the launcher. As of Reloaded II 1.1.0 and above users should not add ReloadedPortable.txt . Reloaded II provides the InitializeASI export, integrating with this loader. NOTE You can install Ultimate ASI Loader to a game from within Reloaded. Please see Edit Application -> Advanced Tools & Options -> Deploy ASI Loader inside the launcher.","title":"Ultimate ASI Loader"},{"location":"InjectionMethods/#sadx-sa2-sonic-r-mania-skc-mod-loader","text":"Mod.ini Name=Reloaded Mod Loader II Author=Sewer56 DLLFile=Reloaded.Mod.Loader.Bootstrapper.dll","title":"SADX, SA2, Sonic R, Mania, SKC Mod Loader"},{"location":"LocalizingReloaded/","text":"Localization Reloaded-II supports localization, meaning that the entirety of the launcher's user interface can be translated to, or viewed in another language. State of Localization At the current moment in time, the implementation of localization is primitive and only covers the launcher (loader & mods are not localized). I am not sure how much demand there is for localizations. How does Localization Work? The launcher loads a XAML (basically XML) file present in the Languages folder of the launcher. In-launcher, the dropdown is automatically populated with the list of every file available in that folder, by name. If no translation exists for a piece of text, the text will default to English (Great Britain), i.e. a string from en-GB.xaml will be used. Where are the Localization Files For a downloaded/release version of Reloaded II, the languages are stored in the Languages folder inside the launcher directory. If you are working with the Source Code of Reloaded II, the localizations are stored in Source/Reloaded.Mod.Launcher/Assets/Languages . Creating Translations Creating translations is very easy. If you are creating a new translation, copy the file en-GB.xaml (default language), and modify the containing text in a text editor. If you are updating a translation, check en-GB.xaml for any missing entries and append them to the end of your translation file. As Reloaded gets updated, new text is always added to the bottom of en-GB.xaml . You can determine if a translation is complete if the last text entry for any language and en-GB.xaml is the same.","title":"Translating Reloaded"},{"location":"LocalizingReloaded/#localization","text":"Reloaded-II supports localization, meaning that the entirety of the launcher's user interface can be translated to, or viewed in another language.","title":"Localization"},{"location":"LocalizingReloaded/#state-of-localization","text":"At the current moment in time, the implementation of localization is primitive and only covers the launcher (loader & mods are not localized). I am not sure how much demand there is for localizations.","title":"State of Localization"},{"location":"LocalizingReloaded/#how-does-localization-work","text":"The launcher loads a XAML (basically XML) file present in the Languages folder of the launcher. In-launcher, the dropdown is automatically populated with the list of every file available in that folder, by name. If no translation exists for a piece of text, the text will default to English (Great Britain), i.e. a string from en-GB.xaml will be used.","title":"How does Localization Work?"},{"location":"LocalizingReloaded/#where-are-the-localization-files","text":"For a downloaded/release version of Reloaded II, the languages are stored in the Languages folder inside the launcher directory. If you are working with the Source Code of Reloaded II, the localizations are stored in Source/Reloaded.Mod.Launcher/Assets/Languages .","title":"Where are the Localization Files"},{"location":"LocalizingReloaded/#creating-translations","text":"Creating translations is very easy. If you are creating a new translation, copy the file en-GB.xaml (default language), and modify the containing text in a text editor. If you are updating a translation, check en-GB.xaml for any missing entries and append them to the end of your translation file. As Reloaded gets updated, new text is always added to the bottom of en-GB.xaml . You can determine if a translation is complete if the last text entry for any language and en-GB.xaml is the same.","title":"Creating Translations"},{"location":"ModTemplate/","text":"Mod Template Features Publish Script This template features a built-in publish script that can be used to create releases of your mod. To run it, open a Powershell prompt in your mod folder and execute the script as such: .\\ Publish . ps1 Once the script completes, ready to upload packages will be output to the Publish/ToUpload . For extended help with the script and examples, consider running: Get-Help .\\ Publish . ps1 -Detailed Delta Updates Reloaded allows for the creation and usage of delta updates. A delta update is an update that only requires the user to download the code and data that has changed, not the whole mod all over. It significantly saves on time and bandwidth usage. # Publish using GitHub Releases as the delta source. ./ Publish . ps1 -MakeDelta true -UseGitHubDelta true -GitHubUserName Sewer56 -GitHubRepoName Reloaded . SharedLib . Hooks . ReloadedII -GitHubFallbackPattern reloaded . sharedlib . hooks . zip # Publish using NuGet as the delta source. ./ Publish . ps1 -MakeDelta true -UseNuGetDelta true -NuGetPackageId reloaded . sharedlib . hooks -NuGetFeedUrl http :// packages . sewer56 . moe : 5000 / v3 / index . json See Delta Updates on more information about the topic. Publishing as ReadyToRun If your mod has a lot of code that is executed at startup, consider using ReadyToRun in order to reduce the startup time. To use ReadyToRun set the BuildR2R flag to true when using the build script. .\\ Publish . ps1 -BuildR2R true R2R is a new type of officially supported file format, which gives a considerable improvement to startup times by shipping native code alongside standard .NET IL code; at the expense of assembly (DLL) size. You can read more about R2R in the following web resources: Conversation about ReadyToRun ReadyToRun Compilation Automated Builds If you are using GitHub to host your project, the mod template contains a script for automatically building and uploading your mod for others to download. It has the following features: - Automatically build mod for GameBanana , GitHub & NuGet . - Automatically create changelog (using git commits). - Automatically upload your mod on tags (releases). - Creates GitHub Release. - Uploads to NuGet (if configured). - If configured correctly, end users will automatically receive update. You can find and/or modify the script at .github/workflows/reloaded.yml . Accessing Build Results To access your automated builds, click the Actions button, select the latest ran workflow and scroll down until you see the Artifacts section. Please note the Artifacts have a limited lifespan, usually GitHub deletes them after around 30 days. Automatic Publishing In order to publish (upload) your mod, simply push a tag to the remote GitHub repository. When the automated build finishes, the script will create a GitHub release and upload the mod to NuGet (if configured). Example of an automated release: Publishing to NuGet Publishing to NuGet requires additional configuration. - Set a NuGet Feed URL - Set a NuGet API Key To set the NuGet feed, open workflows/reloaded.yml and change the NUGET_URL variable. The default is http://packages.sewer56.moe:5000/v3/index.json in which points to the official Reloaded II NuGet repository . To set the API Key, add a Secret named RELOADED_NUGET_KEY . Multiple Mods Per Repository If you want to use the same repository for multiple mods, it is recommended you create a PublishAll.ps1 that runs the publish script multiple times with different parameters. Here is an example: # Set Working Directory Split-Path $MyInvocation . MyCommand . Path | Push-Location [Environment] :: CurrentDirectory = $PWD ./ Publish . ps1 -ProjectPath \"Reloaded.Universal.Redirector/Reloaded.Universal.Redirector.csproj\" ` -PackageName \"Reloaded.Universal.Redirector\" ` -PublishOutputDir \"Publish/ToUpload/Redirector\" ./ Publish . ps1 -ProjectPath \"Reloaded.Universal.Monitor/Reloaded.Universal.Monitor.csproj\" ` -PackageName \"Reloaded.Universal.Monitor\" ` -PublishOutputDir \"Publish/ToUpload/Monitor\" ./ Publish . ps1 -ProjectPath \"Reloaded.Universal.RedirectorMonitor/Reloaded.Universal.RedirectorMonitor.csproj\" ` -PackageName \"Reloaded.Universal.RedirectorMonitor\" ` -PublishOutputDir \"Publish/ToUpload/RedirectorMonitor\" # Restore Working Directory Pop-Location Then modify workflows/reloaded.yml to call PublishAll.ps1 script instead of Publish.ps1 script. Example repositories with this setup: - Reloaded.Universal.Redirector - Heroes.Controller.Hook - Riders.Controller.Hook","title":"Mod Template Features"},{"location":"ModTemplate/#mod-template-features","text":"","title":"Mod Template Features"},{"location":"ModTemplate/#publish-script","text":"This template features a built-in publish script that can be used to create releases of your mod. To run it, open a Powershell prompt in your mod folder and execute the script as such: .\\ Publish . ps1 Once the script completes, ready to upload packages will be output to the Publish/ToUpload . For extended help with the script and examples, consider running: Get-Help .\\ Publish . ps1 -Detailed","title":"Publish Script"},{"location":"ModTemplate/#delta-updates","text":"Reloaded allows for the creation and usage of delta updates. A delta update is an update that only requires the user to download the code and data that has changed, not the whole mod all over. It significantly saves on time and bandwidth usage. # Publish using GitHub Releases as the delta source. ./ Publish . ps1 -MakeDelta true -UseGitHubDelta true -GitHubUserName Sewer56 -GitHubRepoName Reloaded . SharedLib . Hooks . ReloadedII -GitHubFallbackPattern reloaded . sharedlib . hooks . zip # Publish using NuGet as the delta source. ./ Publish . ps1 -MakeDelta true -UseNuGetDelta true -NuGetPackageId reloaded . sharedlib . hooks -NuGetFeedUrl http :// packages . sewer56 . moe : 5000 / v3 / index . json See Delta Updates on more information about the topic.","title":"Delta Updates"},{"location":"ModTemplate/#publishing-as-readytorun","text":"If your mod has a lot of code that is executed at startup, consider using ReadyToRun in order to reduce the startup time. To use ReadyToRun set the BuildR2R flag to true when using the build script. .\\ Publish . ps1 -BuildR2R true R2R is a new type of officially supported file format, which gives a considerable improvement to startup times by shipping native code alongside standard .NET IL code; at the expense of assembly (DLL) size. You can read more about R2R in the following web resources: Conversation about ReadyToRun ReadyToRun Compilation","title":"Publishing as ReadyToRun"},{"location":"ModTemplate/#automated-builds","text":"If you are using GitHub to host your project, the mod template contains a script for automatically building and uploading your mod for others to download. It has the following features: - Automatically build mod for GameBanana , GitHub & NuGet . - Automatically create changelog (using git commits). - Automatically upload your mod on tags (releases). - Creates GitHub Release. - Uploads to NuGet (if configured). - If configured correctly, end users will automatically receive update. You can find and/or modify the script at .github/workflows/reloaded.yml .","title":"Automated Builds"},{"location":"ModTemplate/#accessing-build-results","text":"To access your automated builds, click the Actions button, select the latest ran workflow and scroll down until you see the Artifacts section. Please note the Artifacts have a limited lifespan, usually GitHub deletes them after around 30 days.","title":"Accessing Build Results"},{"location":"ModTemplate/#automatic-publishing","text":"In order to publish (upload) your mod, simply push a tag to the remote GitHub repository. When the automated build finishes, the script will create a GitHub release and upload the mod to NuGet (if configured). Example of an automated release:","title":"Automatic Publishing"},{"location":"ModTemplate/#publishing-to-nuget","text":"Publishing to NuGet requires additional configuration. - Set a NuGet Feed URL - Set a NuGet API Key To set the NuGet feed, open workflows/reloaded.yml and change the NUGET_URL variable. The default is http://packages.sewer56.moe:5000/v3/index.json in which points to the official Reloaded II NuGet repository . To set the API Key, add a Secret named RELOADED_NUGET_KEY .","title":"Publishing to NuGet"},{"location":"ModTemplate/#multiple-mods-per-repository","text":"If you want to use the same repository for multiple mods, it is recommended you create a PublishAll.ps1 that runs the publish script multiple times with different parameters. Here is an example: # Set Working Directory Split-Path $MyInvocation . MyCommand . Path | Push-Location [Environment] :: CurrentDirectory = $PWD ./ Publish . ps1 -ProjectPath \"Reloaded.Universal.Redirector/Reloaded.Universal.Redirector.csproj\" ` -PackageName \"Reloaded.Universal.Redirector\" ` -PublishOutputDir \"Publish/ToUpload/Redirector\" ./ Publish . ps1 -ProjectPath \"Reloaded.Universal.Monitor/Reloaded.Universal.Monitor.csproj\" ` -PackageName \"Reloaded.Universal.Monitor\" ` -PublishOutputDir \"Publish/ToUpload/Monitor\" ./ Publish . ps1 -ProjectPath \"Reloaded.Universal.RedirectorMonitor/Reloaded.Universal.RedirectorMonitor.csproj\" ` -PackageName \"Reloaded.Universal.RedirectorMonitor\" ` -PublishOutputDir \"Publish/ToUpload/RedirectorMonitor\" # Restore Working Directory Pop-Location Then modify workflows/reloaded.yml to call PublishAll.ps1 script instead of Publish.ps1 script. Example repositories with this setup: - Reloaded.Universal.Redirector - Heroes.Controller.Hook - Riders.Controller.Hook","title":"Multiple Mods Per Repository"},{"location":"NativeMods/","text":"About Native Mods Intended for communities who want to try out using Reloaded, transitioning to the mod loader or have a niche reason to use C/C++. Reloaded II has limited support for native C/C++ modifications compiled as DLLs. As standard, this is implemented through the use of DLL Exports. Native mods lack access to components such as the mod loader API but can use some limited mod loader functionality, such as Resume and Suspend provided the right exports are available. Mod Configuration Just like any other mods, native mods with Reloaded require for ModConfig.json to be present. This file must be present to allow the loader to know which DLL to load. You can control which file the mod loader will load for x64 and x86 processes using the following config entries: \"ModNativeDll32\" : \"LostWorldQuickBoot.dll\" , \"ModNativeDll64\" : \"\" , To generate the config file, create a new mod from within the launcher. Exports Entry Points: Reloaded tries to start mods by using the following entry points in order: ReloadedStart InitializeASI Init If none of these entry points is found, the mod will not be loaded. The exported methods should have no parameters and return void . Suspend, Resume, Unload: Reloaded II's Resume , Suspend and Unload functionalities are available for native mods. Virtually identical to their C# counterparts in the IMod interface, they require the following exports: ReloadedSuspend ReloadedResume ReloadedUnload ReloadedCanUnload ReloadedCanSuspend CanUnload and CanSuspend are defined as bool fn() while Suspend , Resume' and 'Unload are defined as void fn() . That said, if you are hooking/detouring functions I would strongly advise against implementing these interfaces unless you know what you are doing. Specifically, you will need to use a good hooking/detouring library that fully respects stacked function hooks. It must allow for hook deactivation in a way that avoids touching both your C++ DLL and overwriting the original prologue of the hooked function. Here is an example of how such a hooking library may be implemented: Reloaded.Hooks . CoreRT/NativeAOT? Yes you can; mad scientist.","title":"Writing Native Mods"},{"location":"NativeMods/#about-native-mods","text":"Intended for communities who want to try out using Reloaded, transitioning to the mod loader or have a niche reason to use C/C++. Reloaded II has limited support for native C/C++ modifications compiled as DLLs. As standard, this is implemented through the use of DLL Exports. Native mods lack access to components such as the mod loader API but can use some limited mod loader functionality, such as Resume and Suspend provided the right exports are available.","title":"About Native Mods"},{"location":"NativeMods/#mod-configuration","text":"Just like any other mods, native mods with Reloaded require for ModConfig.json to be present. This file must be present to allow the loader to know which DLL to load. You can control which file the mod loader will load for x64 and x86 processes using the following config entries: \"ModNativeDll32\" : \"LostWorldQuickBoot.dll\" , \"ModNativeDll64\" : \"\" , To generate the config file, create a new mod from within the launcher.","title":"Mod Configuration"},{"location":"NativeMods/#exports","text":"Entry Points: Reloaded tries to start mods by using the following entry points in order: ReloadedStart InitializeASI Init If none of these entry points is found, the mod will not be loaded. The exported methods should have no parameters and return void . Suspend, Resume, Unload: Reloaded II's Resume , Suspend and Unload functionalities are available for native mods. Virtually identical to their C# counterparts in the IMod interface, they require the following exports: ReloadedSuspend ReloadedResume ReloadedUnload ReloadedCanUnload ReloadedCanSuspend CanUnload and CanSuspend are defined as bool fn() while Suspend , Resume' and 'Unload are defined as void fn() . That said, if you are hooking/detouring functions I would strongly advise against implementing these interfaces unless you know what you are doing. Specifically, you will need to use a good hooking/detouring library that fully respects stacked function hooks. It must allow for hook deactivation in a way that avoids touching both your C++ DLL and overwriting the original prologue of the hooked function. Here is an example of how such a hooking library may be implemented: Reloaded.Hooks .","title":"Exports"},{"location":"NativeMods/#corertnativeaot","text":"Yes you can; mad scientist.","title":"CoreRT/NativeAOT?"},{"location":"NuGetSources/","text":"NuGet Sources NuGet is the primary source for downloading mods and searching for missing mod dependencies. You can directly download mods from NuGet servers via the Download Mods menu. Reloaded comes preconfigured with a single official server intended for hosting code mods. Adding new Sources Additional NuGet servers can be configured from inside the Download Mods menu by pressing Configure Sources . Simply press the New button and then fill a name and URL. The URL should point to something called a NuGet Index . This is a URL which generally ends with /v3/index.json . This URL is generally provided on either a Feed Details or Upload Instructions page. Example URLs: Official NuGet Gallery Index: https://api.nuget.org/v3/index.json Example MyGet Index URL: https://www.myget.org/F/reloaded-ii-tests/api/v3/index.json Official BaGet Server URL: http://packages.sewer56.moe:5000/v3/index.json Please Note: Reloaded handles NuGet errors silently. If it cannot contact a NuGet server; it wouldn't display any error message, etc. Hosting A Server Reloaded-II uses the NuGet V3 API and as such any API compliant NuGet server should work correctly without problems. The official Reloaded server uses a modified version of BaGet , forked as BaGet-Reloaded . Self hosting instructions for a clean VPS are provided in the repository. Other servers/services known to work properly are MyGet as well as the official NuGet Gallery .","title":"NuGet Sources"},{"location":"NuGetSources/#nuget-sources","text":"NuGet is the primary source for downloading mods and searching for missing mod dependencies. You can directly download mods from NuGet servers via the Download Mods menu. Reloaded comes preconfigured with a single official server intended for hosting code mods.","title":"NuGet Sources"},{"location":"NuGetSources/#adding-new-sources","text":"Additional NuGet servers can be configured from inside the Download Mods menu by pressing Configure Sources . Simply press the New button and then fill a name and URL. The URL should point to something called a NuGet Index . This is a URL which generally ends with /v3/index.json . This URL is generally provided on either a Feed Details or Upload Instructions page. Example URLs: Official NuGet Gallery Index: https://api.nuget.org/v3/index.json Example MyGet Index URL: https://www.myget.org/F/reloaded-ii-tests/api/v3/index.json Official BaGet Server URL: http://packages.sewer56.moe:5000/v3/index.json Please Note: Reloaded handles NuGet errors silently. If it cannot contact a NuGet server; it wouldn't display any error message, etc.","title":"Adding new Sources"},{"location":"NuGetSources/#hosting-a-server","text":"Reloaded-II uses the NuGet V3 API and as such any API compliant NuGet server should work correctly without problems. The official Reloaded server uses a modified version of BaGet , forked as BaGet-Reloaded . Self hosting instructions for a clean VPS are provided in the repository. Other servers/services known to work properly are MyGet as well as the official NuGet Gallery .","title":"Hosting A Server"},{"location":"OptimizingMods/","text":"Optimizing Mods This document details various methods and techniques in which mods may be optimized to run for the end user. Focusing mainly on techniques which may not be immediately obvious, the main goal is to obtain better startup times, although some other optimizations are also available. Speed-Focused Optimizations Lazy Loading Lazy loading is simply the process of deferring initialization of an object/thing until the point at which it is needed. Sometimes in your Start() entry point, you might not need to necessarily need to initialize everything related to your mod immediately. For example, if you need to make a connection to a server which will be used later in execution (say you are interacting with a chatroom in a mod etc.), the initial startup of the mod does not have to be halted until this connection is made. You can make the connection in the background and any code depending on the connection can wait for the connection task to finish. Lazy Loading Example Consider a case where you have a code that requires an object, and the object is not required to be used in the Start() method itself. You can create the object just in time for when it is needed: // Function hook by the game/application. public void SomeHookFunction ( int a1 , int b2 ) { // Create someObject is not previously created. if ( someObject == null ) someObject = new SomeClass (); /* Do something with someObject ... */ // Call original function, as part of standard hook procedure _someHook . OriginalFunction ( a1 , b2 ); } This is a very simplified example. The framework built-in class Lazy<T> is very useful. Consider reading this useful resource: https://docs.microsoft.com/en-us/dotnet/framework/performance/lazy-initialization Asynchronous Loading Another great way to not stall mod startup is to perform setup/initialization tasks asynchronously, the Task Parallel Library (TPL) is great for doing this. Consider creating a connection to a server. // Inside class fields. private Task _connectToServerTask ; // Inside Start() _connectToServerTask = Task . Run (() => { /* Code to Connect to a Server */ }); // Somewhere else in code that needs the server to be created. // (Unlikely for this specific scenario). _connectToServerTask . Wait (); // Will stall execution until task completes. Danger: Race Conditions The important thing to note about lazy loading however is the possibility of race conditions for shared resources (such as native memory). Mainly, please do not create function hooks/detours asynchronously . Consider two mods creating hooks for the same function at the same time. When they read the first initial bytes of the function into memory, they would get the same result for the 'original function' to execute. What does this mean? The hooks are unaware of each other (as 'original code'). Calling the 'original function' from either of the hooks would not call the other hooks. In other words, only one of the mods' hooks works. Publish as ReadyToRun .NET Core 3+ has a new type of officially supported file format for publishing applications known as ReadyToRun (abbreviated as R2R). The main advantage of R2R is that it boasts significant improvement to startup times by shipping native code alongside IL code to essentially create hybrid assemblies. For more details, see Mod Template: Ready To Run . Use Shared Libraries See Shared Libraries doc. for the benefits, drawbacks, etc. Space-Focused Optimizations Update Target Framework For older mods, it's possible to save storage space by updating the target framework of your mod to match the latest framework version used by Reloaded. To do so, simply edit your project's .csproj file: <TargetFramework> net5.0 </TargetFramework> The target DLL is now built for .NET 5. Updating your target framework might lead to some DLLs being excluded from your build output (such as System.Text.Json ), since they will be directly available in the newer runtime.","title":"Optimizing Mods"},{"location":"OptimizingMods/#optimizing-mods","text":"This document details various methods and techniques in which mods may be optimized to run for the end user. Focusing mainly on techniques which may not be immediately obvious, the main goal is to obtain better startup times, although some other optimizations are also available.","title":"Optimizing Mods"},{"location":"OptimizingMods/#speed-focused-optimizations","text":"","title":"Speed-Focused Optimizations"},{"location":"OptimizingMods/#lazy-loading","text":"Lazy loading is simply the process of deferring initialization of an object/thing until the point at which it is needed. Sometimes in your Start() entry point, you might not need to necessarily need to initialize everything related to your mod immediately. For example, if you need to make a connection to a server which will be used later in execution (say you are interacting with a chatroom in a mod etc.), the initial startup of the mod does not have to be halted until this connection is made. You can make the connection in the background and any code depending on the connection can wait for the connection task to finish.","title":"Lazy Loading"},{"location":"OptimizingMods/#lazy-loading-example","text":"Consider a case where you have a code that requires an object, and the object is not required to be used in the Start() method itself. You can create the object just in time for when it is needed: // Function hook by the game/application. public void SomeHookFunction ( int a1 , int b2 ) { // Create someObject is not previously created. if ( someObject == null ) someObject = new SomeClass (); /* Do something with someObject ... */ // Call original function, as part of standard hook procedure _someHook . OriginalFunction ( a1 , b2 ); } This is a very simplified example. The framework built-in class Lazy<T> is very useful. Consider reading this useful resource: https://docs.microsoft.com/en-us/dotnet/framework/performance/lazy-initialization","title":"Lazy Loading Example"},{"location":"OptimizingMods/#asynchronous-loading","text":"Another great way to not stall mod startup is to perform setup/initialization tasks asynchronously, the Task Parallel Library (TPL) is great for doing this. Consider creating a connection to a server. // Inside class fields. private Task _connectToServerTask ; // Inside Start() _connectToServerTask = Task . Run (() => { /* Code to Connect to a Server */ }); // Somewhere else in code that needs the server to be created. // (Unlikely for this specific scenario). _connectToServerTask . Wait (); // Will stall execution until task completes.","title":"Asynchronous Loading"},{"location":"OptimizingMods/#danger-race-conditions","text":"The important thing to note about lazy loading however is the possibility of race conditions for shared resources (such as native memory). Mainly, please do not create function hooks/detours asynchronously . Consider two mods creating hooks for the same function at the same time. When they read the first initial bytes of the function into memory, they would get the same result for the 'original function' to execute. What does this mean? The hooks are unaware of each other (as 'original code'). Calling the 'original function' from either of the hooks would not call the other hooks. In other words, only one of the mods' hooks works.","title":"Danger: Race Conditions"},{"location":"OptimizingMods/#publish-as-readytorun","text":".NET Core 3+ has a new type of officially supported file format for publishing applications known as ReadyToRun (abbreviated as R2R). The main advantage of R2R is that it boasts significant improvement to startup times by shipping native code alongside IL code to essentially create hybrid assemblies. For more details, see Mod Template: Ready To Run .","title":"Publish as ReadyToRun"},{"location":"OptimizingMods/#use-shared-libraries","text":"See Shared Libraries doc. for the benefits, drawbacks, etc.","title":"Use Shared Libraries"},{"location":"OptimizingMods/#space-focused-optimizations","text":"","title":"Space-Focused Optimizations"},{"location":"OptimizingMods/#update-target-framework","text":"For older mods, it's possible to save storage space by updating the target framework of your mod to match the latest framework version used by Reloaded. To do so, simply edit your project's .csproj file: <TargetFramework> net5.0 </TargetFramework> The target DLL is now built for .NET 5. Updating your target framework might lead to some DLLs being excluded from your build output (such as System.Text.Json ), since they will be directly available in the newer runtime.","title":"Update Target Framework"},{"location":"ProjectSetup/","text":"Project Setup Once the required tools are installed, you can now begin developing your mod. Creating Your Project Below is information on how to create a new Reloaded project. Once you create your project, you'll be able to open the .csproj file in your preferred IDE of choice. (or the folder where it is contained) From a Supported IDE Some IDEs such as Visual Studio and JetBrains Rider allow you to create a new project directly from IDE. From the Command Line Alternatively, you may create a project from the commandline. Navigate to an empty folder and run the following command. dotnet new reloaded -n <NAMESPACE> --ModName <MOD_NAME> --ModAuthor <MOD_AUTHOR> Replace <NAMESPACE> with your desired name of your project, <MOD_NAME> with the name of the mod as shown to the end user and <MOD_AUTHOR> with your own name. For extended information on other options you can also run: dotnet new reloaded --help Mod Structure Reloaded Projects compose of the following structure: - Metadata File ( ModConfig.json ) - Project Configuration ( .csproj ) - Preview Icon ( Preview.png ) - Your Mod Code ( Program.cs , Mod.cs ) The metadata file contains essential information Metadata File (ModConfig.json) The metadata file contains essential information such as mod author, name, description, and supported applications. Example ModConfig.json : Common Fields: - ModId : A name that uniquely identifies your mod. - ModName : The name of your mod. - ModAuthor : The author of your mod. - ModDescription : A description of your mod. - SupportedAppId : Applications for which the mod should be enabled for by default. Uses lower case exe name. It is recommended to use the format game.type.name for ModId (e.g. sonicheroes.asset.seasidehillmidnight ). ModId should also be human readable. Once you release your mod, do not change ModId!! . The recommended method of editing the metadata file is: - Build your mod (see below). - Editing the config from the Reloaded Launcher - Manage Mods -> Select Your Mod -> Click Edit Mod - Copying the modified ModConfig.json file back to your project. Building Your Mod If you are using an IDE such as Visual Studio, simply build your project. ( Build->Build Solution ). If you are using the command-line you can build using the following command dotnet build The mod will automatically be copied to your Reloaded-II's Mods folder, as long as Reloaded has not been moved since it was last launched. Debugging Your Mod Enable the mod and run the game via Reloaded. If you have built your mod in Debug configuration and a supported IDE/Debugger installed, you should automatically receive a debug prompt like the following when running your game/application. Select your IDE/Debugger of choice and have fun.","title":"2. Creating a New Project"},{"location":"ProjectSetup/#project-setup","text":"Once the required tools are installed, you can now begin developing your mod.","title":"Project Setup"},{"location":"ProjectSetup/#creating-your-project","text":"Below is information on how to create a new Reloaded project. Once you create your project, you'll be able to open the .csproj file in your preferred IDE of choice. (or the folder where it is contained)","title":"Creating Your Project"},{"location":"ProjectSetup/#from-a-supported-ide","text":"Some IDEs such as Visual Studio and JetBrains Rider allow you to create a new project directly from IDE.","title":"From a Supported IDE"},{"location":"ProjectSetup/#from-the-command-line","text":"Alternatively, you may create a project from the commandline. Navigate to an empty folder and run the following command. dotnet new reloaded -n <NAMESPACE> --ModName <MOD_NAME> --ModAuthor <MOD_AUTHOR> Replace <NAMESPACE> with your desired name of your project, <MOD_NAME> with the name of the mod as shown to the end user and <MOD_AUTHOR> with your own name. For extended information on other options you can also run: dotnet new reloaded --help","title":"From the Command Line"},{"location":"ProjectSetup/#mod-structure","text":"Reloaded Projects compose of the following structure: - Metadata File ( ModConfig.json ) - Project Configuration ( .csproj ) - Preview Icon ( Preview.png ) - Your Mod Code ( Program.cs , Mod.cs ) The metadata file contains essential information","title":"Mod Structure"},{"location":"ProjectSetup/#metadata-file-modconfigjson","text":"The metadata file contains essential information such as mod author, name, description, and supported applications. Example ModConfig.json : Common Fields: - ModId : A name that uniquely identifies your mod. - ModName : The name of your mod. - ModAuthor : The author of your mod. - ModDescription : A description of your mod. - SupportedAppId : Applications for which the mod should be enabled for by default. Uses lower case exe name. It is recommended to use the format game.type.name for ModId (e.g. sonicheroes.asset.seasidehillmidnight ). ModId should also be human readable. Once you release your mod, do not change ModId!! . The recommended method of editing the metadata file is: - Build your mod (see below). - Editing the config from the Reloaded Launcher - Manage Mods -> Select Your Mod -> Click Edit Mod - Copying the modified ModConfig.json file back to your project.","title":"Metadata File (ModConfig.json)"},{"location":"ProjectSetup/#building-your-mod","text":"If you are using an IDE such as Visual Studio, simply build your project. ( Build->Build Solution ). If you are using the command-line you can build using the following command dotnet build The mod will automatically be copied to your Reloaded-II's Mods folder, as long as Reloaded has not been moved since it was last launched.","title":"Building Your Mod"},{"location":"ProjectSetup/#debugging-your-mod","text":"Enable the mod and run the game via Reloaded. If you have built your mod in Debug configuration and a supported IDE/Debugger installed, you should automatically receive a debug prompt like the following when running your game/application. Select your IDE/Debugger of choice and have fun.","title":"Debugging Your Mod"},{"location":"ProjectStructure/","text":"Core Components Reloaded.Mod.Launcher + Reloaded.Mod.Launcher.Lib The WPF application responsible for the management of settings, mods, registered applications as well as loading and communicating with the mod loader. Reloaded.Mod.Launcher contains the view (WPF) portion. Reloaded.Mod.Launcher.Lib contains the actual launcher code, including ViewModels . Powered by .NET 5.X at the time of last update. Reloaded.Mod.Loader The mod loader itself, it unironically loads mods. For each mod, the loader provides isolation through a plugin system such that they can load each of their own dependencies without version clashes: For example one mod could load Json.NET 10 and another Json.NET 11 , despite both having the same DLL name. The loader also supports a local server, which can be accessed by other clients such as the launcher. Said server provides support for e.g. Loading/Unloading/Suspending/Resuming mods and getting their state at runtime. Reloaded.Mod.Loader.Bootstrapper (C++) Simple native bootstrapper DLL, which when injected into a process, loads the .NET Runtime and Reloaded.Mod.Loader . This DLL can be copied to integrate the mod loader into other loaders seamlessly. Custom entry points for some common DLL Hijacking based loaders like Ultimate ASI Loader are also supported. By default it loads asynchronously. Due to Windows DLL Loader lock, it cannot unfortunately run synchronously to ensure mods execute before application code, however support is added for restarting the process via Reloaded's launcher, which will ensure mods load before application code. This bootstrapper also ensures the loader is only loaded once into the process. Reloaded.Mod.Launcher.Kernel32AddressDumper Simple utility program that is executed by Reloaded.Mod.Launcher during startup. It is used to extract the address of the LoadLibraryW function to allow for DLL Injection into x86 processes from an x64 one. Tools Reloaded.Mod.Installer One click custom written installer for Reloaded. Installs all necessary dependencies and gets the mod loader up and running in under a minute. Written in .NET 4.7.2 which should be preinstalled in any up to date Windows version. Ships as Setup.exe . NuGetConverter Simple program for generating NuGet packages which can be later uploaded to a repository and consumed within Reloaded. Intended for usage in CI/CD scenarios, where updates need to be automatically generated without the use of a GUI. Reloaded-II NuGet Package Converter Converts mod folders or archives into NuGet packages. Usage: NuGetConverter.exe <Mod Folder or Archive Path> <Output Path>. Example: NuGetConverter.exe Mod.zip Mod.nupkg Example: NuGetConverter.exe reloaded.test.mod reloaded.test.mod.nupkg Example: NuGetConverter.exe reloaded.test.mod ./packages/reloaded.test.mod.nupkg Reloaded.Publisher Simple program that generates update files and releases without requiring the use of the full launcher. Intended for usage in CI/CD scenarios, where updates need to be automatically generated without the use of a GUI. Libraries Reloaded.Mod.Interfaces Project containing interfaces for mod loader components to be shared between the mod loader and other external components such as mods. This package contains no code, only interfaces and is the only requirement to get a Reloaded mod started. Usually compiles down to tiny ~8KB DLL. Reloaded.Mod.Loader.IO Contains the code for reading all and monitoring configuration files in Reloaded. Can be used as an external library outside of R-II. Reloaded.Mod.Loader.Server A library allowing you to send remote commands to an instance of Reloaded living inside a process. Contains the complete implementation for the mod loader server including all of the messages, responses and general driving code. It contains a fully featured client class for easy communication with the mod loader server. Only the host class is contained in the actual mod loader itself. Reloaded.Mod.Loader.Update The part of Reloaded responsible for fetching and applying updates for the individual mod packages. Separated out from Reloaded.Mod.Launcher.Lib for potential reuse. Reloaded.Mod.Loader.Update.Packaging Subset of Reloaded.Mod.Loader.Update containing only the necessary code to create individual update packages. Separated out to keep tool binaries smaller. Reloaded.Mod.Installer.DependencyInstaller Subset of Reloaded.Mod.Loader.Update . Contains the code to search for missing dependencies and install them. Separated out in otder to keep the Reloaded.Mod.Installer binary small. Reloaded.Mod.Shared Contains items shared between the Launcher , Loader and Kernel32AddressDumper . Things that don't fit into any other library go here.","title":"Project Structure"},{"location":"ProjectStructure/#core-components","text":"","title":"Core Components"},{"location":"ProjectStructure/#reloadedmodlauncher-reloadedmodlauncherlib","text":"The WPF application responsible for the management of settings, mods, registered applications as well as loading and communicating with the mod loader. Reloaded.Mod.Launcher contains the view (WPF) portion. Reloaded.Mod.Launcher.Lib contains the actual launcher code, including ViewModels . Powered by .NET 5.X at the time of last update.","title":"Reloaded.Mod.Launcher + Reloaded.Mod.Launcher.Lib"},{"location":"ProjectStructure/#reloadedmodloader","text":"The mod loader itself, it unironically loads mods. For each mod, the loader provides isolation through a plugin system such that they can load each of their own dependencies without version clashes: For example one mod could load Json.NET 10 and another Json.NET 11 , despite both having the same DLL name. The loader also supports a local server, which can be accessed by other clients such as the launcher. Said server provides support for e.g. Loading/Unloading/Suspending/Resuming mods and getting their state at runtime.","title":"Reloaded.Mod.Loader"},{"location":"ProjectStructure/#reloadedmodloaderbootstrapper-c","text":"Simple native bootstrapper DLL, which when injected into a process, loads the .NET Runtime and Reloaded.Mod.Loader . This DLL can be copied to integrate the mod loader into other loaders seamlessly. Custom entry points for some common DLL Hijacking based loaders like Ultimate ASI Loader are also supported. By default it loads asynchronously. Due to Windows DLL Loader lock, it cannot unfortunately run synchronously to ensure mods execute before application code, however support is added for restarting the process via Reloaded's launcher, which will ensure mods load before application code. This bootstrapper also ensures the loader is only loaded once into the process.","title":"Reloaded.Mod.Loader.Bootstrapper (C++)"},{"location":"ProjectStructure/#reloadedmodlauncherkernel32addressdumper","text":"Simple utility program that is executed by Reloaded.Mod.Launcher during startup. It is used to extract the address of the LoadLibraryW function to allow for DLL Injection into x86 processes from an x64 one.","title":"Reloaded.Mod.Launcher.Kernel32AddressDumper"},{"location":"ProjectStructure/#tools","text":"","title":"Tools"},{"location":"ProjectStructure/#reloadedmodinstaller","text":"One click custom written installer for Reloaded. Installs all necessary dependencies and gets the mod loader up and running in under a minute. Written in .NET 4.7.2 which should be preinstalled in any up to date Windows version. Ships as Setup.exe .","title":"Reloaded.Mod.Installer"},{"location":"ProjectStructure/#nugetconverter","text":"Simple program for generating NuGet packages which can be later uploaded to a repository and consumed within Reloaded. Intended for usage in CI/CD scenarios, where updates need to be automatically generated without the use of a GUI. Reloaded-II NuGet Package Converter Converts mod folders or archives into NuGet packages. Usage: NuGetConverter.exe <Mod Folder or Archive Path> <Output Path>. Example: NuGetConverter.exe Mod.zip Mod.nupkg Example: NuGetConverter.exe reloaded.test.mod reloaded.test.mod.nupkg Example: NuGetConverter.exe reloaded.test.mod ./packages/reloaded.test.mod.nupkg","title":"NuGetConverter"},{"location":"ProjectStructure/#reloadedpublisher","text":"Simple program that generates update files and releases without requiring the use of the full launcher. Intended for usage in CI/CD scenarios, where updates need to be automatically generated without the use of a GUI.","title":"Reloaded.Publisher"},{"location":"ProjectStructure/#libraries","text":"","title":"Libraries"},{"location":"ProjectStructure/#reloadedmodinterfaces","text":"Project containing interfaces for mod loader components to be shared between the mod loader and other external components such as mods. This package contains no code, only interfaces and is the only requirement to get a Reloaded mod started. Usually compiles down to tiny ~8KB DLL.","title":"Reloaded.Mod.Interfaces"},{"location":"ProjectStructure/#reloadedmodloaderio","text":"Contains the code for reading all and monitoring configuration files in Reloaded. Can be used as an external library outside of R-II.","title":"Reloaded.Mod.Loader.IO"},{"location":"ProjectStructure/#reloadedmodloaderserver","text":"A library allowing you to send remote commands to an instance of Reloaded living inside a process. Contains the complete implementation for the mod loader server including all of the messages, responses and general driving code. It contains a fully featured client class for easy communication with the mod loader server. Only the host class is contained in the actual mod loader itself.","title":"Reloaded.Mod.Loader.Server"},{"location":"ProjectStructure/#reloadedmodloaderupdate","text":"The part of Reloaded responsible for fetching and applying updates for the individual mod packages. Separated out from Reloaded.Mod.Launcher.Lib for potential reuse.","title":"Reloaded.Mod.Loader.Update"},{"location":"ProjectStructure/#reloadedmodloaderupdatepackaging","text":"Subset of Reloaded.Mod.Loader.Update containing only the necessary code to create individual update packages. Separated out to keep tool binaries smaller.","title":"Reloaded.Mod.Loader.Update.Packaging"},{"location":"ProjectStructure/#reloadedmodinstallerdependencyinstaller","text":"Subset of Reloaded.Mod.Loader.Update . Contains the code to search for missing dependencies and install them. Separated out in otder to keep the Reloaded.Mod.Installer binary small.","title":"Reloaded.Mod.Installer.DependencyInstaller"},{"location":"ProjectStructure/#reloadedmodshared","text":"Contains items shared between the Launcher , Loader and Kernel32AddressDumper . Things that don't fit into any other library go here.","title":"Reloaded.Mod.Shared"},{"location":"QuickStart/","text":"Quick Start Add an Application First step to getting started with Reloaded is to add an Application you'll be modifying. This can be found on the bottom left corner of the launcher, with the + button. Make sure to add the App and not the app's launcher. Extract Mods To install mods, simply extract a downloaded zip or 7z file to the Mods folder. If there is no single folder inside the downloaded mod, create one yourself. Configure Mods Some mods might support additional configuration, allowing you to tweak things. If the \"Configure Mod\" is red when the mod is highlighted, the mod can be configured. Enable Mods To enable mods, simply press the square checkbox. A mod is enabled if the checkbox is red, disabled if it is grey. Once you are done, press Launch Application . Note Reloaded uses .exe name to determine which mods should automatically be assigned to an application. If a mod does not show in the application, click the 3 gear button ( Manage Mods ). From there, select the mod that you have just extracted from the list and check your game on the list below.","title":"Quick Start"},{"location":"QuickStart/#quick-start","text":"","title":"Quick Start"},{"location":"QuickStart/#add-an-application","text":"First step to getting started with Reloaded is to add an Application you'll be modifying. This can be found on the bottom left corner of the launcher, with the + button. Make sure to add the App and not the app's launcher.","title":"Add an Application"},{"location":"QuickStart/#extract-mods","text":"To install mods, simply extract a downloaded zip or 7z file to the Mods folder. If there is no single folder inside the downloaded mod, create one yourself.","title":"Extract Mods"},{"location":"QuickStart/#configure-mods","text":"Some mods might support additional configuration, allowing you to tweak things. If the \"Configure Mod\" is red when the mod is highlighted, the mod can be configured.","title":"Configure Mods"},{"location":"QuickStart/#enable-mods","text":"To enable mods, simply press the square checkbox. A mod is enabled if the checkbox is red, disabled if it is grey. Once you are done, press Launch Application . Note Reloaded uses .exe name to determine which mods should automatically be assigned to an application. If a mod does not show in the application, click the 3 gear button ( Manage Mods ). From there, select the mod that you have just extracted from the list and check your game on the list below.","title":"Enable Mods"},{"location":"Reloaded-II-Architecture/","text":"High Level Architecture Code Injection Steps The typical bootstrapping mechanism for Reloaded II looks like the following: - Launcher starts the application as a suspended state. - Launcher uses DLL injection to inject the Loader Bootstrapper . - The Bootstrapper loads the .NET runtime and the Loader. - The Loader parses configurations and loads individual mods. - Process is resumed by Launcher. Mods are loaded using a shared interface, implemented by mods. This works by forcing mods to load the same version of the interface that the main Loader was compiled against. Detecting Reloaded II Reloaded II is not intended to bypass DRM or anti-cheating software. It makes no attempts to hide itself. Reloaded II can be easily detected through one of the following two methods. Module List. If Reloaded.Mod.Loader.dll is found in the process' module list, there's a good chance that Reloaded is present inside the target process. Memory Mapped File. Alternatively, you can try opening a memory mapped file handle to Reloaded-Mod-Loader-Server-PID-{a} where {a} is the PID of the process you want to check. If the handle is valid, Reloaded is running inside the target process. Service: Local Server Injected Reloaded instances inside the target process host a local UDP server which can easily be interacted with by connecting. The library Reloaded.Mod.Loader.Server can be used to interact with the server.","title":"High Level Architecture"},{"location":"Reloaded-II-Architecture/#high-level-architecture","text":"","title":"High Level Architecture"},{"location":"Reloaded-II-Architecture/#code-injection-steps","text":"The typical bootstrapping mechanism for Reloaded II looks like the following: - Launcher starts the application as a suspended state. - Launcher uses DLL injection to inject the Loader Bootstrapper . - The Bootstrapper loads the .NET runtime and the Loader. - The Loader parses configurations and loads individual mods. - Process is resumed by Launcher. Mods are loaded using a shared interface, implemented by mods. This works by forcing mods to load the same version of the interface that the main Loader was compiled against.","title":"Code Injection Steps"},{"location":"Reloaded-II-Architecture/#detecting-reloaded-ii","text":"Reloaded II is not intended to bypass DRM or anti-cheating software. It makes no attempts to hide itself. Reloaded II can be easily detected through one of the following two methods. Module List. If Reloaded.Mod.Loader.dll is found in the process' module list, there's a good chance that Reloaded is present inside the target process. Memory Mapped File. Alternatively, you can try opening a memory mapped file handle to Reloaded-Mod-Loader-Server-PID-{a} where {a} is the PID of the process you want to check. If the handle is valid, Reloaded is running inside the target process.","title":"Detecting Reloaded II"},{"location":"Reloaded-II-Architecture/#service-local-server","text":"Injected Reloaded instances inside the target process host a local UDP server which can easily be interacted with by connecting. The library Reloaded.Mod.Loader.Server can be used to interact with the server.","title":"Service: Local Server"},{"location":"Reloaded-vs-Reloaded-II/","text":"Reloaded vs Reloaded II Reloaded I The original Reloaded Mod Loader works by splitting the launcher application and loader application. Doing so separates the concerns of managing the mods and actually getting them running inside the target application. When the user selects Launch in the application, the Launcher would merely launch the Loader with a specific set of commandline parameters. On startup, the Loader application would read a config at the given path (from commandline parameters), do some setup and inject the relevant mod DLLs. The Loader application would then also act as a local server that can be used for printing debug messages. Advantages This is more lightweight in terms of RAM usage as the actual mod loader is not injected inside of the target process and can be closed down after DLL injection occurs, although the benefits are minimal. Reloaded Mod DLLs supported by other mod loaders. Because of AppDomain plumbing code (see below) and use of DLL Exports. On the flipside developer must either export make their own C++ bootstrapper and export DllMain or mod loader must know to run the exported Main method. Reloaded-II can also be bootstrapped via the \"DLL Loader\" method to be executed by other loaders itself, nullifying this point entirely. Support of DLLs programmed in arbitrary Native/Managed programming languages (provided DLL exports are supported). In theory there is no reason that Reloaded II's architecture couldn't support native DLLs. Only catch is that it will have to distinguish them from .NET ones so a bit more code. Disadvantages Does not support \"Any CPU\" assemblies. The X86 and X64 versions of the assemblies have to be manually identified by the mod loader or specified by the user. Slower. Each DLL Injection requires at the very least the creation of a new thread inside the remote process CreateRemoteThread . Debugging print-outs are delayed due to networking (even on the same machine). An application can print something and then immediately crash. The print will not be delivered as it has not fully sent before the application crashed. In addition, connecting back to the local server adds to the startup time of the program. In theory ~50-100ms may not be much but it stacks once multiple mods with code are loaded. Each mod requires to have its own copy of the plumbing code to transfer its execution to another AppDomain. This is bad if changes are required to the plumbing code. Now suddenly every mod needs updated. The plumbing code can be in another assembly and that assembly would load the actual mod DLL. (Work on Reloaded Refactor/Reloaded II began by the point of realization) This is necessary because otherwise, if two mods will have different versions of the same library/assembly e.g. Mod A has JSON.NET 10, Mod B has JSON.NET 11, one mod will crash, killing the whole application. If Mod A (JSON.NET 10) gets loaded first, Mod B will report System.IO.FileNotFoundException. on trying to load JSON.NET 11. If Mod B (JSON.NET 11) gets loaded last, Mod A will likely report MissingMethodException or TypeLoadException . Reloaded II In the case of Reloaded II, things change considerably as there is only one standalone application, the WPF Graphical User Interface. What instead happens is that rather than the Launcher running the Loader as a separate standalone application, the loader instead ships in the form of an injectable DLL. In this case the actual loader itself is injected into the target application, which will in turn initialize and load successive mods using the native .NET APIs. Once Reloaded is injected, the WPF Graphical User Interface (as well as other programs) can check if Reloaded is present by looking in the modules list of the target. If the Reloaded DLL is there, it can be assumed mods are loaded. Interacting with Reloaded II Injected Reloaded inside the target process hosts a local UDP server which can easily be interacted with by connecting. As opposed to having a one server and then a client for every single loaded mod, there is only one server (and one client if the Launcher is connected). Having to create only one host significantly reduces startup time. Reloaded II vs Reloaded I Below is a summarized list of advantages and disadvantages of the Reloaded II approach over the Reloaded I approach. Given that many advantages and disadvantages are already listed above, this list will focus on the aspects not mentioned prior. Advantages Tagging. It is very easy to determine whether Reloaded is active/has performed operations on an application. Simply check if the Reloaded DLL is loaded inside the target process. This also makes it possible (and much easier) for other programs to interact with Reloaded. No need to e.g. store the server port in an external file in the case of needing to re-connect. Loader as a Service. The mod loader can now natively send events to the subscribing mods. (With a tiny bit extra effort). The mods can also send events to the mod loader. This requires a bit of extra effort as the events would need to cross AppDomain boundaries but as no complications are introduced for programmers/mod developers this is ok. This is also of course possible with Reloaded I but requires sending messages using networking. This may not seem like a huge issue until you notice everything has to be serializable and e.g. subscribing multiple methods is extra painful. Faster. There is very likely to be some kind of overlap in the libraries used by the Reloaded Loader DLL and the mods. Provided that loading mods without re-JIT'ing code proves possible with the use of AppDomain 's LoaderOptimization options. In the very worst case, Reflection is faster than Dll Injection + Reflection , with additional time also saved not connecting and starting a local server. See Reloaded I - Disadvantages Disadvantages See Reloaded I - Advantages .","title":"Reloaded vs Reloaded II"},{"location":"Reloaded-vs-Reloaded-II/#reloaded-vs-reloaded-ii","text":"","title":"Reloaded vs Reloaded II"},{"location":"Reloaded-vs-Reloaded-II/#reloaded-i","text":"The original Reloaded Mod Loader works by splitting the launcher application and loader application. Doing so separates the concerns of managing the mods and actually getting them running inside the target application. When the user selects Launch in the application, the Launcher would merely launch the Loader with a specific set of commandline parameters. On startup, the Loader application would read a config at the given path (from commandline parameters), do some setup and inject the relevant mod DLLs. The Loader application would then also act as a local server that can be used for printing debug messages.","title":"Reloaded I"},{"location":"Reloaded-vs-Reloaded-II/#advantages","text":"This is more lightweight in terms of RAM usage as the actual mod loader is not injected inside of the target process and can be closed down after DLL injection occurs, although the benefits are minimal. Reloaded Mod DLLs supported by other mod loaders. Because of AppDomain plumbing code (see below) and use of DLL Exports. On the flipside developer must either export make their own C++ bootstrapper and export DllMain or mod loader must know to run the exported Main method. Reloaded-II can also be bootstrapped via the \"DLL Loader\" method to be executed by other loaders itself, nullifying this point entirely. Support of DLLs programmed in arbitrary Native/Managed programming languages (provided DLL exports are supported). In theory there is no reason that Reloaded II's architecture couldn't support native DLLs. Only catch is that it will have to distinguish them from .NET ones so a bit more code.","title":"Advantages"},{"location":"Reloaded-vs-Reloaded-II/#disadvantages","text":"Does not support \"Any CPU\" assemblies. The X86 and X64 versions of the assemblies have to be manually identified by the mod loader or specified by the user. Slower. Each DLL Injection requires at the very least the creation of a new thread inside the remote process CreateRemoteThread . Debugging print-outs are delayed due to networking (even on the same machine). An application can print something and then immediately crash. The print will not be delivered as it has not fully sent before the application crashed. In addition, connecting back to the local server adds to the startup time of the program. In theory ~50-100ms may not be much but it stacks once multiple mods with code are loaded. Each mod requires to have its own copy of the plumbing code to transfer its execution to another AppDomain. This is bad if changes are required to the plumbing code. Now suddenly every mod needs updated. The plumbing code can be in another assembly and that assembly would load the actual mod DLL. (Work on Reloaded Refactor/Reloaded II began by the point of realization) This is necessary because otherwise, if two mods will have different versions of the same library/assembly e.g. Mod A has JSON.NET 10, Mod B has JSON.NET 11, one mod will crash, killing the whole application. If Mod A (JSON.NET 10) gets loaded first, Mod B will report System.IO.FileNotFoundException. on trying to load JSON.NET 11. If Mod B (JSON.NET 11) gets loaded last, Mod A will likely report MissingMethodException or TypeLoadException .","title":"Disadvantages"},{"location":"Reloaded-vs-Reloaded-II/#reloaded-ii","text":"In the case of Reloaded II, things change considerably as there is only one standalone application, the WPF Graphical User Interface. What instead happens is that rather than the Launcher running the Loader as a separate standalone application, the loader instead ships in the form of an injectable DLL. In this case the actual loader itself is injected into the target application, which will in turn initialize and load successive mods using the native .NET APIs. Once Reloaded is injected, the WPF Graphical User Interface (as well as other programs) can check if Reloaded is present by looking in the modules list of the target. If the Reloaded DLL is there, it can be assumed mods are loaded.","title":"Reloaded II"},{"location":"Reloaded-vs-Reloaded-II/#interacting-with-reloaded-ii","text":"Injected Reloaded inside the target process hosts a local UDP server which can easily be interacted with by connecting. As opposed to having a one server and then a client for every single loaded mod, there is only one server (and one client if the Launcher is connected). Having to create only one host significantly reduces startup time.","title":"Interacting with Reloaded II"},{"location":"Reloaded-vs-Reloaded-II/#reloaded-ii-vs-reloaded-i","text":"Below is a summarized list of advantages and disadvantages of the Reloaded II approach over the Reloaded I approach. Given that many advantages and disadvantages are already listed above, this list will focus on the aspects not mentioned prior.","title":"Reloaded II vs Reloaded I"},{"location":"Reloaded-vs-Reloaded-II/#advantages_1","text":"Tagging. It is very easy to determine whether Reloaded is active/has performed operations on an application. Simply check if the Reloaded DLL is loaded inside the target process. This also makes it possible (and much easier) for other programs to interact with Reloaded. No need to e.g. store the server port in an external file in the case of needing to re-connect. Loader as a Service. The mod loader can now natively send events to the subscribing mods. (With a tiny bit extra effort). The mods can also send events to the mod loader. This requires a bit of extra effort as the events would need to cross AppDomain boundaries but as no complications are introduced for programmers/mod developers this is ok. This is also of course possible with Reloaded I but requires sending messages using networking. This may not seem like a huge issue until you notice everything has to be serializable and e.g. subscribing multiple methods is extra painful. Faster. There is very likely to be some kind of overlap in the libraries used by the Reloaded Loader DLL and the mods. Provided that loading mods without re-JIT'ing code proves possible with the use of AppDomain 's LoaderOptimization options. In the very worst case, Reflection is faster than Dll Injection + Reflection , with additional time also saved not connecting and starting a local server. See Reloaded I - Disadvantages","title":"Advantages"},{"location":"Reloaded-vs-Reloaded-II/#disadvantages_1","text":"See Reloaded I - Advantages .","title":"Disadvantages"},{"location":"Troubleshooting/","text":"Troubleshooting Debugging Bug: CS7069: Reference to type \u2018...\u2019 claims it is defined in \u2018...\u2019, but it could not be found. This is a bug of the Visual Studio Debugger , for more information, please look at and upvote this issue. . If you are a developer, you may encounter this issue if you run multiple mods which use different versions of the same DLL in their build output. At the moment, it seems Visual Studio cannot differentiate the assembly used by your mod's \"AssemblyLoadContext\"; and will always assume the first assembly with matching name is in use. Workaround May not work if your mod has dependencies which use the same DLL but worth a try. Open %appdata%/Reloaded-Mod-Loader-II/ReloadedII.json in a text editor. Set LoadModsInParallel to false . Drag and drop your mod to the top of the mod list so it gets loaded first.","title":"Troubleshooting"},{"location":"Troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"Troubleshooting/#debugging-bug-cs7069-reference-to-type-claims-it-is-defined-in-but-it-could-not-be-found","text":"This is a bug of the Visual Studio Debugger , for more information, please look at and upvote this issue. . If you are a developer, you may encounter this issue if you run multiple mods which use different versions of the same DLL in their build output. At the moment, it seems Visual Studio cannot differentiate the assembly used by your mod's \"AssemblyLoadContext\"; and will always assume the first assembly with matching name is in use.","title":"Debugging Bug: CS7069: Reference to type \u2018...\u2019 claims it is defined in \u2018...\u2019, but it could not be found."},{"location":"Troubleshooting/#workaround","text":"May not work if your mod has dependencies which use the same DLL but worth a try. Open %appdata%/Reloaded-Mod-Loader-II/ReloadedII.json in a text editor. Set LoadModsInParallel to false . Drag and drop your mod to the top of the mod list so it gets loaded first.","title":"Workaround"},{"location":"CheatSheet/CallingHookingGameFunctions/","text":"Calling Game Functions In the modern day, there exist multiple ways to call game functions from C#. In this part of the cheat sheet, we're going to focus on the most common way of calling game functions; that is through Reloaded.Hooks . Reloaded.Hooks is an advanced, general purpose library for manipulating native functions in memory. It was specifically created as part of the Reloaded Project towards the journey to Reloaded-II. This page serves as an introduction to Reloaded.Hooks there are more features to the library than detailed here, consider visiting the full documentation here . Additional Resources: - Reloaded.Hooks Wiki - What is Reloaded.Hooks Where to Find Reloaded.Hooks Reloaded.Hooks comes preconfigured out of the box as part of the mod template, so you don't need to do anything special to use it. // From the mod template. public Mod ( IReloadedHooks hooks , ILogger logger ) { // IReloadedHooks: It's right here!! } Defining Game Functions Calling, hooking and performing other operations with native functions with Reloaded.Hooks is performed through the use of delegates. Delegates should be with Reloaded's FunctionAttribute . // RenderWare Graphics: This function is usually step one to widescreen hacks :) [Function(CallingConventions.Cdecl)] public delegate void RwCameraSetViewWindow ( ref RWCamera RwCamera , ref RWView view ); There are two FunctionAttribute(s) , namely X86.FunctionAttribute and X64.FunctionAttribute . Depending on the game you are working with, you may wish to apply one, the other or both. Advanced Example Info In the real world, compilers will often optimise function calls to optimise for performance. This will often lead to the function using non-standard conventions, such as accepting parameters via registers where normally the stack should be used. This is more common in x86 (32-bit) games rather than x64 games. Reloaded.Hooks allows for mapping parameters to given registers. /// <summary> /// Reads a ANM/HAnim stream from a .ONE archive. Returns address of a decompressed ANM file. /// </summary> /// <param name=\"fileIndex\">[EAX] The index of the file inside the .ONE archive (starting with 2)</param> /// <param name=\"addressToDecompressTo\">[ECX] The address to which the file inside the ONE archive will be decompressed to.</param> /// <param name=\"thisPointer\">\"This\" pointer for the ONEFILE class instance.</param> /// <returns>The address containing the read in ANM (RenderWare Hierarchical Animation) stream.</returns> [Function(new[] { Register . eax , Register . ecx }, Register . eax , StackCleanup . Callee )] public delegate void * OneFileLoadHAnimation ( int fileIndex , void * addressToDecompressTo , ref ONEFILE thisPointer ); /* Lifted from a disassembly of Sonic Heroes */ The defined function has the following properties: - Two parameters (left to right) in registers EAX and ECX. - Return register of EAX. - \"Callee\" stack cleanup. In most non-Reloaded environments (e.g. C++ with MinHook ) you'd usually write some custom inline assembly code to glue together your code and the optimised native function. This is not necessary here. Deciphering the Function Signature Info Some disassemblers may contain useful information about how the function is called. Below is guidance on deciphering the function signatures in some common disassemblers. Please note that disassemblers are not perfect; they can and will sometimes make mistakes. IDA Pro (Decompiler): // Example void * __userpurge OneFileLoadHAnimation @ < eax >( RwUInt32 type @ < eax >, void * dest @ < ecx >, ONEFILE * this ) // Breakdown FUNCTION_NAME @ < eax > in function name specifies return register is EAX . type @ < eax > specifies the ` type ` argument is passed via EAX register . dest @ < ecx > specifies the ` dest ` argument is passed via ECX register . remaining parameters are passed via stack . // Extra Info (IDA Specific) _userpurge == ' Callee ' Stack Cleanup _usercall == ' Caller ' Stack Cleanup Ghidra: Right click function name and click Edit Function . Inside the dialog, you will find the following: Note: Ghidra did not disassemble this correctly; I manually fixed this function for this example. Binary Ninja: This one is pretty self explanatory. // Example void * __stdcall OneFileLoadHAnimation ( int32_t arg1 @ eax , char * arg2 @ ecx , char * arg3 ) General: Some disassemblers might not provide information on return registers and/or stack cleanup because they are implied by the given convention (such as __stdcall ). Consider using the following presets in Reloaded.Hooks to determine these settings. X86 Calling Conventions (Presets) X64 Calling Conventions (Presets) Calling Functions To call the game function(s), create a delegate by calling IReloadedHooks' CreateWrapper<T> function. // 0x0064AC80 is the address of function in native memory. var rwCameraSetViewWindow = hooks . CreateWrapper < RwCameraSetViewWindow >( 0 x0064AC80 ); // You may now call the delegate instance/native/game fuction like if it was your own. rwCameraSetViewWindow ( camera , view ); Hooking Functions Danger When you create the hook, you MUST store the returned IHook<T> in a place where it will not be garbage collected. Usually a class field is sufficient, otherwise use a static list/variable. Function hooking/calling/trampolining is performed by calling the IReloadedHooks CreateHook<T> function. private IHook < CreateFileA > _createFileAHook ; /* Constructor */ public SomeClass ( IReloadedHooks hooks ) { // Get Address of Windows API function. var createFileAPointer = GetProcAddress ( LoadLibraryW ( \"kernel32\" ), \"CreateFileA\" ); // Create the hook (don't forget to call Activate()). _createFileAHook = hooks . CreateHook < CreateFileA >( CreateFileAImpl , ( long ) createFileAPointer ). Activate (); } /* Hook Function */ private static IntPtr CreateFileAImpl ( string filename , FileAccess access , FileShare share , IntPtr securityAttributes , FileMode creationDisposition , FileAttributes flagsAndAttributes , IntPtr templateFile ) { // Filter out non-files such as HID devices, print rest to console if (! filename . StartsWith ( @\"\\\\?\\\" )) Console . WriteLine ( $\"Opening File {filename}\" ); // Code above this comment is executed before the original Windows API code. var returnValue = _createFileAHook . OriginalFunction ( filename , access , share , securityAttributes , creationDisposition , flagsAndAttributes , templateFile ); // Code under this comment is executed after the original Windows API code. return returnValue ; } IFunction<T> Worth noting due to its usefulness, Function<T> is a commonly used API that wraps a native function given a pointer and instance of IReloadedHooks . Usage: _addFunction = new Function < Calculator . AddFunction >( functionAddress , hooks ); // With this class you can easily perform common operations, for example... // Hook Function _addHook = _addFunction . Hook ( Hookfunction ). Activate (); // Call Function _addFunction . GetWrapper ()( x , y ); This library is useful when you are e.g. building a library for others to use for hacking a specific game.","title":"2. Calling & Hooking Game Functions"},{"location":"CheatSheet/CallingHookingGameFunctions/#calling-game-functions","text":"In the modern day, there exist multiple ways to call game functions from C#. In this part of the cheat sheet, we're going to focus on the most common way of calling game functions; that is through Reloaded.Hooks . Reloaded.Hooks is an advanced, general purpose library for manipulating native functions in memory. It was specifically created as part of the Reloaded Project towards the journey to Reloaded-II. This page serves as an introduction to Reloaded.Hooks there are more features to the library than detailed here, consider visiting the full documentation here . Additional Resources: - Reloaded.Hooks Wiki - What is Reloaded.Hooks","title":"Calling Game Functions"},{"location":"CheatSheet/CallingHookingGameFunctions/#where-to-find-reloadedhooks","text":"Reloaded.Hooks comes preconfigured out of the box as part of the mod template, so you don't need to do anything special to use it. // From the mod template. public Mod ( IReloadedHooks hooks , ILogger logger ) { // IReloadedHooks: It's right here!! }","title":"Where to Find Reloaded.Hooks"},{"location":"CheatSheet/CallingHookingGameFunctions/#defining-game-functions","text":"Calling, hooking and performing other operations with native functions with Reloaded.Hooks is performed through the use of delegates. Delegates should be with Reloaded's FunctionAttribute . // RenderWare Graphics: This function is usually step one to widescreen hacks :) [Function(CallingConventions.Cdecl)] public delegate void RwCameraSetViewWindow ( ref RWCamera RwCamera , ref RWView view ); There are two FunctionAttribute(s) , namely X86.FunctionAttribute and X64.FunctionAttribute . Depending on the game you are working with, you may wish to apply one, the other or both.","title":"Defining Game Functions"},{"location":"CheatSheet/CallingHookingGameFunctions/#advanced-example","text":"Info In the real world, compilers will often optimise function calls to optimise for performance. This will often lead to the function using non-standard conventions, such as accepting parameters via registers where normally the stack should be used. This is more common in x86 (32-bit) games rather than x64 games. Reloaded.Hooks allows for mapping parameters to given registers. /// <summary> /// Reads a ANM/HAnim stream from a .ONE archive. Returns address of a decompressed ANM file. /// </summary> /// <param name=\"fileIndex\">[EAX] The index of the file inside the .ONE archive (starting with 2)</param> /// <param name=\"addressToDecompressTo\">[ECX] The address to which the file inside the ONE archive will be decompressed to.</param> /// <param name=\"thisPointer\">\"This\" pointer for the ONEFILE class instance.</param> /// <returns>The address containing the read in ANM (RenderWare Hierarchical Animation) stream.</returns> [Function(new[] { Register . eax , Register . ecx }, Register . eax , StackCleanup . Callee )] public delegate void * OneFileLoadHAnimation ( int fileIndex , void * addressToDecompressTo , ref ONEFILE thisPointer ); /* Lifted from a disassembly of Sonic Heroes */ The defined function has the following properties: - Two parameters (left to right) in registers EAX and ECX. - Return register of EAX. - \"Callee\" stack cleanup. In most non-Reloaded environments (e.g. C++ with MinHook ) you'd usually write some custom inline assembly code to glue together your code and the optimised native function. This is not necessary here.","title":"Advanced Example"},{"location":"CheatSheet/CallingHookingGameFunctions/#deciphering-the-function-signature","text":"Info Some disassemblers may contain useful information about how the function is called. Below is guidance on deciphering the function signatures in some common disassemblers. Please note that disassemblers are not perfect; they can and will sometimes make mistakes. IDA Pro (Decompiler): // Example void * __userpurge OneFileLoadHAnimation @ < eax >( RwUInt32 type @ < eax >, void * dest @ < ecx >, ONEFILE * this ) // Breakdown FUNCTION_NAME @ < eax > in function name specifies return register is EAX . type @ < eax > specifies the ` type ` argument is passed via EAX register . dest @ < ecx > specifies the ` dest ` argument is passed via ECX register . remaining parameters are passed via stack . // Extra Info (IDA Specific) _userpurge == ' Callee ' Stack Cleanup _usercall == ' Caller ' Stack Cleanup Ghidra: Right click function name and click Edit Function . Inside the dialog, you will find the following: Note: Ghidra did not disassemble this correctly; I manually fixed this function for this example. Binary Ninja: This one is pretty self explanatory. // Example void * __stdcall OneFileLoadHAnimation ( int32_t arg1 @ eax , char * arg2 @ ecx , char * arg3 ) General: Some disassemblers might not provide information on return registers and/or stack cleanup because they are implied by the given convention (such as __stdcall ). Consider using the following presets in Reloaded.Hooks to determine these settings. X86 Calling Conventions (Presets) X64 Calling Conventions (Presets)","title":"Deciphering the Function Signature"},{"location":"CheatSheet/CallingHookingGameFunctions/#calling-functions","text":"To call the game function(s), create a delegate by calling IReloadedHooks' CreateWrapper<T> function. // 0x0064AC80 is the address of function in native memory. var rwCameraSetViewWindow = hooks . CreateWrapper < RwCameraSetViewWindow >( 0 x0064AC80 ); // You may now call the delegate instance/native/game fuction like if it was your own. rwCameraSetViewWindow ( camera , view );","title":"Calling Functions"},{"location":"CheatSheet/CallingHookingGameFunctions/#hooking-functions","text":"Danger When you create the hook, you MUST store the returned IHook<T> in a place where it will not be garbage collected. Usually a class field is sufficient, otherwise use a static list/variable. Function hooking/calling/trampolining is performed by calling the IReloadedHooks CreateHook<T> function. private IHook < CreateFileA > _createFileAHook ; /* Constructor */ public SomeClass ( IReloadedHooks hooks ) { // Get Address of Windows API function. var createFileAPointer = GetProcAddress ( LoadLibraryW ( \"kernel32\" ), \"CreateFileA\" ); // Create the hook (don't forget to call Activate()). _createFileAHook = hooks . CreateHook < CreateFileA >( CreateFileAImpl , ( long ) createFileAPointer ). Activate (); } /* Hook Function */ private static IntPtr CreateFileAImpl ( string filename , FileAccess access , FileShare share , IntPtr securityAttributes , FileMode creationDisposition , FileAttributes flagsAndAttributes , IntPtr templateFile ) { // Filter out non-files such as HID devices, print rest to console if (! filename . StartsWith ( @\"\\\\?\\\" )) Console . WriteLine ( $\"Opening File {filename}\" ); // Code above this comment is executed before the original Windows API code. var returnValue = _createFileAHook . OriginalFunction ( filename , access , share , securityAttributes , creationDisposition , flagsAndAttributes , templateFile ); // Code under this comment is executed after the original Windows API code. return returnValue ; }","title":"Hooking Functions"},{"location":"CheatSheet/CallingHookingGameFunctions/#ifunctiont","text":"Worth noting due to its usefulness, Function<T> is a commonly used API that wraps a native function given a pointer and instance of IReloadedHooks . Usage: _addFunction = new Function < Calculator . AddFunction >( functionAddress , hooks ); // With this class you can easily perform common operations, for example... // Hook Function _addHook = _addFunction . Hook ( Hookfunction ). Activate (); // Call Function _addFunction . GetWrapper ()( x , y ); This library is useful when you are e.g. building a library for others to use for hacking a specific game.","title":"IFunction&lt;T>"},{"location":"CheatSheet/MemoryManipulation/","text":"Memory Manipulation Warning The Cheat Sheet is a work in progress. If you think it can be improved, please message me or contribute to the wiki. Info The goal of the Cheat Sheet is to provide information to help you work within a Reloaded environment. It is not a game hacking/reverse engineering guide, but rather a way to help you if you are unfamiliar working with C# or Reloaded. This page provides various common use case examples of memory manipulation with Reloaded. Using Pointers Info When using pointers in C#, you must use the unsafe keyword, which you can apply to a class, method or block of code. Classic and the most commonly known method of manipulating memory, C style pointers. public unsafe void PointerExample () { int * ptr = ( int *) 0 xA0B8C0 ; // Set 32-bit value at 0xA0B8C0 to 1. * ptr = 1 ; // Read back the value from 0xA0B8C0 int value = * ptr ; } Using Structs Pointer arithmetic is also possible with structs in C#. public struct Point { public float X ; public float Y ; } public unsafe void PointerStructExample () { var ptr = ( Point *) 0 xA0B8C0 ; // Set X coordinate to 2000.0f ptr -> X = 2000.0f ; } Using Structs (Custom Offsets) C# allows you to set custom offsets for fields inside structs. [StructLayout(LayoutKind.Explicit)] public struct Player { [FieldOffset(0x24)] public byte State ; [FieldOffset(0x100)] public Vector3 Position ; } There is no need to insert dummy values as you might need to do in other languages. These structs work fine with pointers and other C# functionality. ASLR Although rarely, some games might use ASLR (Address Space Layout Randomization) to randomize the address where the contents of the game's executable is loaded in memory. To get the base address of the EXE in memory, use Process.GetCurrentProcess().MainModule.BaseAddress . // baseAddress: location where the 1st byte of the EXE resides in memory var baseAddress = ( long ) Process . GetCurrentProcess (). MainModule . BaseAddress ; var functionAddress = baseAddress + 0 x4D6920 ; When you see, for example Tsonic_win.exe+4D6920 in a tool like Cheat Engine, it really means means baseAddress + 0x4D6920 . Using the Reloaded.Memory Library Info The following examples make use of the Reloaded.Memory NuGet library. If you are unfamiliar with NuGet, please use one of the following guides: - Commandline (dotnet) - Visual Studio - Rider Below are some common Reloaded.Memory use cases related to Memory Manipulation, for more utilities, please consult the Reloaded.Memory documentation . Simple Memory Read/Write public void ReloadedMemoryExample () { var memory = Memory . Instance ; // in Reloaded.Memory.Sources // Set 32-bit value at 0xA0B8C0 to 1. memory . Write ( 0 xA0B8C0 , 1 ); // Read back the value from 0xA0B8C0 int value = memory . Read < int >( 0 xA0B8C0 ); } Protected Memory Regions Sometimes, sections of memory may be protected such that writing to them using or the regular Write methods will cause an error. When this happens you will usually see an error that looks like Access Violation (0xC0000005) . This usually happens when you make attempts to directly overwrite game code. Reloaded.Memory provides a workaround for this. public void ReloadedMemorySafeWrite () { // SafeWrite will change memory permissions, // write your value and restore the original permissions Memory . Instance . SafeWrite ( 0 xA0B8C0 , 1 ); } Alternatively, you can use ChangePermission to change the permissions and never bother with them again. public void ReloadedMemoryChangePermissions () { var value = 1 ; var memory = Memory . Instance ; // Change the permissions so this region of memory is writable. memory . ChangePermission (( IntPtr ) 0 xA0B8C0 , ref value , Kernel32 . MEM_PROTECTION . PAGE_EXECUTE_READWRITE ); // You can now write to the memory as usual. memory . Write ( 0 xA0B8C0 , value ); } Pointers by Reference The RefPointer<T> class can be used to convert pointers to references. public unsafe void RefPointerExample () { ref int value = ref RefPointer < int >. Create ( 0 xA0B8C0 ); value = 1 ; // Write to 0xA0B8C0 int copy = value ; // Read from 0xA0B8C0 } Fixed Array Pointers The FixedArrayPointer<T> struct is also worth a mention, as it implements the necessary interfaces to make use of features such as LINQ. // Assume 0xA0B8C0 contains an array of character physics (struct) in some game. // Assume there are 16 characters. var characterPhysicsArray = new FixedArrayPtr < CharacterPhysics >(( ulong ) 0 xA0B8C0 , 16 ); // Calculating min, max, average air acceleration using LINQ float minAccel = characterPhysicsArray . Min ( physics => physics . AirAcceleration ); float maxAccel = characterPhysicsArray . Max ( physics => physics . AirAcceleration ); float averageAccel = characterPhysicsArray . Average ( physics => physics . AirAcceleration ); Memory Marshalling Example \"Marshalling\" is another feature supported in Reloaded.Memory when reading or writing data. Marshalling is the process of converting between a C# object and a C struct or C++ class. The following example reads a struct, which contains a string with fixed length. public struct CustomFileHeader { /// <summary> /// Contains the actual filename of the file as ASCII encoded bytes. /// Stored as fixed size of 32 bytes, no null terminator. /// </summary> [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)] public string Name ; public uint Offset ; public uint Length ; } private static void MarshallingExample () { var memory = Memory . Instance ; // Read. memory . Read < CustomFileHeader >( memoryLocation , out var header , true ); // true to enable marshalling // Change the name (make sure less than 32 characters) header . Name = \"CoolNewHeaderName\" ; // Write it back memory . Write ( memoryLocation , customHeader ); }","title":"1. Memory Manipulation"},{"location":"CheatSheet/MemoryManipulation/#memory-manipulation","text":"Warning The Cheat Sheet is a work in progress. If you think it can be improved, please message me or contribute to the wiki. Info The goal of the Cheat Sheet is to provide information to help you work within a Reloaded environment. It is not a game hacking/reverse engineering guide, but rather a way to help you if you are unfamiliar working with C# or Reloaded. This page provides various common use case examples of memory manipulation with Reloaded.","title":"Memory Manipulation"},{"location":"CheatSheet/MemoryManipulation/#using-pointers","text":"Info When using pointers in C#, you must use the unsafe keyword, which you can apply to a class, method or block of code. Classic and the most commonly known method of manipulating memory, C style pointers. public unsafe void PointerExample () { int * ptr = ( int *) 0 xA0B8C0 ; // Set 32-bit value at 0xA0B8C0 to 1. * ptr = 1 ; // Read back the value from 0xA0B8C0 int value = * ptr ; }","title":"Using Pointers"},{"location":"CheatSheet/MemoryManipulation/#using-structs","text":"Pointer arithmetic is also possible with structs in C#. public struct Point { public float X ; public float Y ; } public unsafe void PointerStructExample () { var ptr = ( Point *) 0 xA0B8C0 ; // Set X coordinate to 2000.0f ptr -> X = 2000.0f ; }","title":"Using Structs"},{"location":"CheatSheet/MemoryManipulation/#using-structs-custom-offsets","text":"C# allows you to set custom offsets for fields inside structs. [StructLayout(LayoutKind.Explicit)] public struct Player { [FieldOffset(0x24)] public byte State ; [FieldOffset(0x100)] public Vector3 Position ; } There is no need to insert dummy values as you might need to do in other languages. These structs work fine with pointers and other C# functionality.","title":"Using Structs (Custom Offsets)"},{"location":"CheatSheet/MemoryManipulation/#aslr","text":"Although rarely, some games might use ASLR (Address Space Layout Randomization) to randomize the address where the contents of the game's executable is loaded in memory. To get the base address of the EXE in memory, use Process.GetCurrentProcess().MainModule.BaseAddress . // baseAddress: location where the 1st byte of the EXE resides in memory var baseAddress = ( long ) Process . GetCurrentProcess (). MainModule . BaseAddress ; var functionAddress = baseAddress + 0 x4D6920 ; When you see, for example Tsonic_win.exe+4D6920 in a tool like Cheat Engine, it really means means baseAddress + 0x4D6920 .","title":"ASLR"},{"location":"CheatSheet/MemoryManipulation/#using-the-reloadedmemory-library","text":"Info The following examples make use of the Reloaded.Memory NuGet library. If you are unfamiliar with NuGet, please use one of the following guides: - Commandline (dotnet) - Visual Studio - Rider Below are some common Reloaded.Memory use cases related to Memory Manipulation, for more utilities, please consult the Reloaded.Memory documentation .","title":"Using the Reloaded.Memory Library"},{"location":"CheatSheet/MemoryManipulation/#simple-memory-readwrite","text":"public void ReloadedMemoryExample () { var memory = Memory . Instance ; // in Reloaded.Memory.Sources // Set 32-bit value at 0xA0B8C0 to 1. memory . Write ( 0 xA0B8C0 , 1 ); // Read back the value from 0xA0B8C0 int value = memory . Read < int >( 0 xA0B8C0 ); }","title":"Simple Memory Read/Write"},{"location":"CheatSheet/MemoryManipulation/#protected-memory-regions","text":"Sometimes, sections of memory may be protected such that writing to them using or the regular Write methods will cause an error. When this happens you will usually see an error that looks like Access Violation (0xC0000005) . This usually happens when you make attempts to directly overwrite game code. Reloaded.Memory provides a workaround for this. public void ReloadedMemorySafeWrite () { // SafeWrite will change memory permissions, // write your value and restore the original permissions Memory . Instance . SafeWrite ( 0 xA0B8C0 , 1 ); } Alternatively, you can use ChangePermission to change the permissions and never bother with them again. public void ReloadedMemoryChangePermissions () { var value = 1 ; var memory = Memory . Instance ; // Change the permissions so this region of memory is writable. memory . ChangePermission (( IntPtr ) 0 xA0B8C0 , ref value , Kernel32 . MEM_PROTECTION . PAGE_EXECUTE_READWRITE ); // You can now write to the memory as usual. memory . Write ( 0 xA0B8C0 , value ); }","title":"Protected Memory Regions"},{"location":"CheatSheet/MemoryManipulation/#pointers-by-reference","text":"The RefPointer<T> class can be used to convert pointers to references. public unsafe void RefPointerExample () { ref int value = ref RefPointer < int >. Create ( 0 xA0B8C0 ); value = 1 ; // Write to 0xA0B8C0 int copy = value ; // Read from 0xA0B8C0 }","title":"Pointers by Reference"},{"location":"CheatSheet/MemoryManipulation/#fixed-array-pointers","text":"The FixedArrayPointer<T> struct is also worth a mention, as it implements the necessary interfaces to make use of features such as LINQ. // Assume 0xA0B8C0 contains an array of character physics (struct) in some game. // Assume there are 16 characters. var characterPhysicsArray = new FixedArrayPtr < CharacterPhysics >(( ulong ) 0 xA0B8C0 , 16 ); // Calculating min, max, average air acceleration using LINQ float minAccel = characterPhysicsArray . Min ( physics => physics . AirAcceleration ); float maxAccel = characterPhysicsArray . Max ( physics => physics . AirAcceleration ); float averageAccel = characterPhysicsArray . Average ( physics => physics . AirAcceleration );","title":"Fixed Array Pointers"},{"location":"CheatSheet/MemoryManipulation/#memory-marshalling-example","text":"\"Marshalling\" is another feature supported in Reloaded.Memory when reading or writing data. Marshalling is the process of converting between a C# object and a C struct or C++ class. The following example reads a struct, which contains a string with fixed length. public struct CustomFileHeader { /// <summary> /// Contains the actual filename of the file as ASCII encoded bytes. /// Stored as fixed size of 32 bytes, no null terminator. /// </summary> [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)] public string Name ; public uint Offset ; public uint Length ; } private static void MarshallingExample () { var memory = Memory . Instance ; // Read. memory . Read < CustomFileHeader >( memoryLocation , out var header , true ); // true to enable marshalling // Change the name (make sure less than 32 characters) header . Name = \"CoolNewHeaderName\" ; // Write it back memory . Write ( memoryLocation , customHeader ); }","title":"Memory Marshalling Example"},{"location":"CheatSheet/ReloadedIIApi/","text":"Reloaded API Reloaded-II provides a simple, easy to use API that can be used for receiving various events from the mod loader, query status of other mods and perform some common operations such as logging. Where to find the API. In the mod template, have a look at Program.cs . When your mod first executes at startup, Reloaded will call the Start (or StartEx ) method. You should subscribe to any events that you want to receive from Reloaded-II in this method. public void StartEx ( IModLoaderV1 loaderApi , IModConfigV1 modConfig ) { // Previous code omitted.. // From template _mod = new Mod ( _hooks , _logger ); // Ideally here, at the end of the method. } Some Common API Events // Subscribing to events from `StartEx` method. public void StartEx ( IModLoaderV1 loaderApi , IModConfigV1 modConfig ) { // Prior code omitted from this secion... var configFolder = _modLoader . GetModConfigDirectory ( modConfig . ModId ); _modLoader . OnModLoaderInitialized += OnModLoaderInitialized ; _modLoader . ModUnloading += ModUnloading ; _modLoader . ModLoading += OnModLoading ; _modLoader . ModLoaded += OnModLoaded ; } // Called when all the mods have been loaded at startup. private void OnModLoaderInitialized () { } // Called right before a mod is unloaded. private void ModUnloading ( IModV1 mod , IModConfigV1 config ) { } // Called right before a mod is loaded. private void OnModLoading ( IModV1 mod , IModConfigV1 config ) { } // Called after a mod is loaded private void OnModLoaded ( IModV1 mod , IModConfigV1 config ) { } When consuming events, the parameters passed to the event handlers contain the oldest available versions of each interface. To use the newest available version, simply cast the interface. var newMod = ( IMod ) mod Newest versions have no version suffix, so for IModConfigV1 you should cast to IModConfig and for IModV1 you should cast to IMod etc. Logging API Reloaded-II provides a logging API; which you can use to log messages to the console and the log file. Example: _logger . WriteLineAsync ( \"Hello World\" ); Asynchronous Logging If you need to very frequently log messages, it is recommended to use the asynchronous logging API instead. _logger . WriteLineAsync ( \"Async Hello World\" ); Calling this method will add the message to a queue. This queue is handled by a background thread; so the method will return immediately instead of stalling the application. Events The logger exposes some events, such as for intercepting logged messages. _logger . OnWriteLine += LoggerOnOnWriteLine ; private void OnWriteLine ( object? sender , ( string text , Color color ) e ) { /* Do something with new line. */ } This can be useful if you would like to e.g. display the log in-game.","title":"4. Reloaded API"},{"location":"CheatSheet/ReloadedIIApi/#reloaded-api","text":"Reloaded-II provides a simple, easy to use API that can be used for receiving various events from the mod loader, query status of other mods and perform some common operations such as logging.","title":"Reloaded API"},{"location":"CheatSheet/ReloadedIIApi/#where-to-find-the-api","text":"In the mod template, have a look at Program.cs . When your mod first executes at startup, Reloaded will call the Start (or StartEx ) method. You should subscribe to any events that you want to receive from Reloaded-II in this method. public void StartEx ( IModLoaderV1 loaderApi , IModConfigV1 modConfig ) { // Previous code omitted.. // From template _mod = new Mod ( _hooks , _logger ); // Ideally here, at the end of the method. }","title":"Where to find the API."},{"location":"CheatSheet/ReloadedIIApi/#some-common-api-events","text":"// Subscribing to events from `StartEx` method. public void StartEx ( IModLoaderV1 loaderApi , IModConfigV1 modConfig ) { // Prior code omitted from this secion... var configFolder = _modLoader . GetModConfigDirectory ( modConfig . ModId ); _modLoader . OnModLoaderInitialized += OnModLoaderInitialized ; _modLoader . ModUnloading += ModUnloading ; _modLoader . ModLoading += OnModLoading ; _modLoader . ModLoaded += OnModLoaded ; } // Called when all the mods have been loaded at startup. private void OnModLoaderInitialized () { } // Called right before a mod is unloaded. private void ModUnloading ( IModV1 mod , IModConfigV1 config ) { } // Called right before a mod is loaded. private void OnModLoading ( IModV1 mod , IModConfigV1 config ) { } // Called after a mod is loaded private void OnModLoaded ( IModV1 mod , IModConfigV1 config ) { } When consuming events, the parameters passed to the event handlers contain the oldest available versions of each interface. To use the newest available version, simply cast the interface. var newMod = ( IMod ) mod Newest versions have no version suffix, so for IModConfigV1 you should cast to IModConfig and for IModV1 you should cast to IMod etc.","title":"Some Common API Events"},{"location":"CheatSheet/ReloadedIIApi/#logging-api","text":"Reloaded-II provides a logging API; which you can use to log messages to the console and the log file. Example: _logger . WriteLineAsync ( \"Hello World\" );","title":"Logging API"},{"location":"CheatSheet/ReloadedIIApi/#asynchronous-logging","text":"If you need to very frequently log messages, it is recommended to use the asynchronous logging API instead. _logger . WriteLineAsync ( \"Async Hello World\" ); Calling this method will add the message to a queue. This queue is handled by a background thread; so the method will return immediately instead of stalling the application.","title":"Asynchronous Logging"},{"location":"CheatSheet/ReloadedIIApi/#events","text":"The logger exposes some events, such as for intercepting logged messages. _logger . OnWriteLine += LoggerOnOnWriteLine ; private void OnWriteLine ( object? sender , ( string text , Color color ) e ) { /* Do something with new line. */ } This can be useful if you would like to e.g. display the log in-game.","title":"Events"},{"location":"CheatSheet/SignatureScanning/","text":"Signature Scanning Info This page provides the basic essential background knowledge about signature scanning to spread awareness. This technique is often underutilised by new and upcoming communities; games get updated and on some services, it's not possible to downgrade. Please remember that the Cheat Sheet is not a game hacking guide. Modifying applications which get frequent updates can become very challenging. Every update shuffles around everything in the executables: functions, variables etc. Many other mods that don't use signature scanning for maintained games break instantly every update. This can be avoided with a technique called signature scanning . About Signature Scanning Signature Scanning is all about scanning memory to find a known sequence of bytes which matches a sequence of bytes you have previously identified (e.g. bytes at start of a function). That's it. Most common use cases for signature scanning: - Scanning for the start of a function. - Scanning for the code that accesses a variable. When doing Sigscanning, you should be looking for CODE and NOT DATA . You look for assembly instructions, such as mov eax, [ecx] . If you want to find e.g. the money variable, you scan for the code that accesses that address. Creating Signatures An example signature for getting address to levelId variable in a game. // Signature: 89 15 [?? ?? ?? ??] EB ?? A3 ?? ?? ?? ?? // LevelId : Found Address of Signature + 2 (See brackets) // Instruction // Bytes mov levelId , edx // 89 15 [?? ?? ?? ??] <= Level ID | jmp loc_4354A1 // EB ?? mov someOtherVariable , eax // A3 ?? ?? ?? ?? When you are creating a signature, you want to exclude parts of the code that are likely to change between different versions of the game. This includes items such as variable addresses and jmp targets . In the above example, these bytes are marked as ?? and the signature scanner will accept any value in that position as valid. Viewing bytes corresponding to instructions: IDA: Options -> General -> Number of Opcode Bytes Ghidra: Ghidra shows bytes by default. Binary Ninja (Cloud): Press dropdown for current tab and check Show Bytes . Hints on generating signatures by hand Help The guidance here could be better. It's generally recommended to automate this process using existing scripts, however if you want to do this by hand; here is a bit of guidance: - You can generally tell by just seeing the desired address/offset right there in the bytes. - Using x86 instruction set reference can be useful to separate the instruction from operands. - Copy the code to an assembler like FASM, change operand, see which bytes change. - Ghidra Specific: Right Click -> Instruction Info -> See: Operand Mask . Tool: SigMaker for IDA Help There exist more tools for creating signatures out there. If you are experienced with any of them, consider contributing to the wiki. You can find SigMaker here . To install simply drop the plugin into the plugins directory. You can then access SigMaker via Edit -> Plugins -> SigMaker or by pressing Ctrl + Alt + S . A successfully found signature looks like E8 ? ? ? ? 5B 5E 83 C4 18 and will be printed in the Output window. Direct Signature to Code The following method can be used to generate a signature that when scanned, will give the exact address of the code you are looking for. Highlight a line of code. Generate a signature. ( Ctrl + Alt + S -> Create IDA Pattern from Selection ). Test the pattern. ( Ctrl + Alt + S -> Test IDA Pattern ). If there is more than 1 result, highlight 1 more line of assembly and repeat the process until there is only 1 result. Use this signature. This generally generates longer signatures than Auto Create Pattern , but these signatures should be safer for cases where you are generating signatures for code in the middle of a function. Auto Create Pattern If you decide to instead use Auto Create Pattern to generate the signature, you might receive an output that looks like this: direct reference: [actual address in first opcode] E8 ? ? ? ? 5B 5E 83 C4 18 And if you scan for the pattern, you might find yourself at a different address. 0060913F 024 E8 [7C 13 00 00] call ChangeStrategyMode // <= Here 00609144 024 5B pop ebx Auto-create pattern will often generate a pattern to some code that call (s) the function you are looking for. In order to convert this to the actual function address at runtime, you will need to do the following. Extract the relative address [shown in brackets] from the call instruction (in this case bytes 0x7C130000). Add this relative address to address of next instruction. // Reference C# code to do this: // instructionAddress: Address of found signature in RAM. // instructionLength: Length of the instruction. unsafe byte * CallInstructionToAbsoluteAddress ( byte * instructionAddress , int instructionLength ) { var nextInstructionAddress = instructionAddress + instructionLength ; var offset = *( instructionAddress + 1 ); // extract [ 7C 13 00 00 ] return ( nextInstructionAddress + offset ); } If the signature scan result says sig to containing function , add the number in brackets to your result. Tool: MakeSig For Ghidra You can find MakeSig here . To install simply drop makesig.py into your ghidra_scripts directory. If you do not know where this directory is, you can check in Window -> Script Manager (or using the Script Manager button in the toolbar) then Right Click -> Script Directories . The default directory is ~/ghidra_scripts although in this window you can add another directory where scripts will be searched for. With the script installed you can then use it from the Script Manager window by searching for makesig and double clicking it. You can also assign a keyboard shortcut to run the script by Right Click -> Assign Key Binding . After running it once you can also rerun it with Ctrl + Shift + R or using the rerun button at the end of the toolbar. When running the script you can either create a signature for the start of the function or the currently selected instruction, the found signature such as E8 ?? ?? ?? ?? 8B 45 ?? 89 47 will be printed to the console. Searching for Signatures Info The following example makes use of the Reloaded.Memory.SigScan NuGet library. You can find its documentation here . The following is an example of how you would search for the signature in the Creating Signatures section above: // Initialize the scanner. var thisProcess = Process . GetCurrentProcess (); var baseAddress = thisProcess . MainModule . BaseAddress ; var exeSize = thisProcess . MainModule . ModuleMemorySize ; using var scanner = new Scanner (( byte *) baseAddress , exeSize ); // Search for a given pattern // Note: If created signature using SigMaker, replace ? with ??. var result = scanner . FindPattern ( \"89 15 ?? ?? ?? ?? EB ?? A3 ?? ?? ?? ??\" ); if (! result . Found ) throw new Exception ( \"Signature for getting LevelId not found.\" ); // Address of `mov levelId, edx` var codeAddress = baseAddress + result . Offset ; // Address of `levelId` (skip 89 15) var levelIdPointer = ( int **)( codeAddress + 2 ); // Get address of 'levelId' in memory. int * levelId = * levelIdPointer ; Additional Resources Guided Hacking: Pattern Scanning Guide AlliedMods: Pattern Scanning Reloaded Wiki","title":"3. Signature Scanning"},{"location":"CheatSheet/SignatureScanning/#signature-scanning","text":"Info This page provides the basic essential background knowledge about signature scanning to spread awareness. This technique is often underutilised by new and upcoming communities; games get updated and on some services, it's not possible to downgrade. Please remember that the Cheat Sheet is not a game hacking guide. Modifying applications which get frequent updates can become very challenging. Every update shuffles around everything in the executables: functions, variables etc. Many other mods that don't use signature scanning for maintained games break instantly every update. This can be avoided with a technique called signature scanning .","title":"Signature Scanning"},{"location":"CheatSheet/SignatureScanning/#about-signature-scanning","text":"Signature Scanning is all about scanning memory to find a known sequence of bytes which matches a sequence of bytes you have previously identified (e.g. bytes at start of a function). That's it. Most common use cases for signature scanning: - Scanning for the start of a function. - Scanning for the code that accesses a variable. When doing Sigscanning, you should be looking for CODE and NOT DATA . You look for assembly instructions, such as mov eax, [ecx] . If you want to find e.g. the money variable, you scan for the code that accesses that address.","title":"About Signature Scanning"},{"location":"CheatSheet/SignatureScanning/#creating-signatures","text":"An example signature for getting address to levelId variable in a game. // Signature: 89 15 [?? ?? ?? ??] EB ?? A3 ?? ?? ?? ?? // LevelId : Found Address of Signature + 2 (See brackets) // Instruction // Bytes mov levelId , edx // 89 15 [?? ?? ?? ??] <= Level ID | jmp loc_4354A1 // EB ?? mov someOtherVariable , eax // A3 ?? ?? ?? ?? When you are creating a signature, you want to exclude parts of the code that are likely to change between different versions of the game. This includes items such as variable addresses and jmp targets . In the above example, these bytes are marked as ?? and the signature scanner will accept any value in that position as valid.","title":"Creating Signatures"},{"location":"CheatSheet/SignatureScanning/#viewing-bytes-corresponding-to-instructions","text":"IDA: Options -> General -> Number of Opcode Bytes Ghidra: Ghidra shows bytes by default. Binary Ninja (Cloud): Press dropdown for current tab and check Show Bytes .","title":"Viewing bytes corresponding to instructions:"},{"location":"CheatSheet/SignatureScanning/#hints-on-generating-signatures-by-hand","text":"Help The guidance here could be better. It's generally recommended to automate this process using existing scripts, however if you want to do this by hand; here is a bit of guidance: - You can generally tell by just seeing the desired address/offset right there in the bytes. - Using x86 instruction set reference can be useful to separate the instruction from operands. - Copy the code to an assembler like FASM, change operand, see which bytes change. - Ghidra Specific: Right Click -> Instruction Info -> See: Operand Mask .","title":"Hints on generating signatures by hand"},{"location":"CheatSheet/SignatureScanning/#tool-sigmaker-for-ida","text":"Help There exist more tools for creating signatures out there. If you are experienced with any of them, consider contributing to the wiki. You can find SigMaker here . To install simply drop the plugin into the plugins directory. You can then access SigMaker via Edit -> Plugins -> SigMaker or by pressing Ctrl + Alt + S . A successfully found signature looks like E8 ? ? ? ? 5B 5E 83 C4 18 and will be printed in the Output window.","title":"Tool: SigMaker for IDA"},{"location":"CheatSheet/SignatureScanning/#direct-signature-to-code","text":"The following method can be used to generate a signature that when scanned, will give the exact address of the code you are looking for. Highlight a line of code. Generate a signature. ( Ctrl + Alt + S -> Create IDA Pattern from Selection ). Test the pattern. ( Ctrl + Alt + S -> Test IDA Pattern ). If there is more than 1 result, highlight 1 more line of assembly and repeat the process until there is only 1 result. Use this signature. This generally generates longer signatures than Auto Create Pattern , but these signatures should be safer for cases where you are generating signatures for code in the middle of a function.","title":"Direct Signature to Code"},{"location":"CheatSheet/SignatureScanning/#auto-create-pattern","text":"If you decide to instead use Auto Create Pattern to generate the signature, you might receive an output that looks like this: direct reference: [actual address in first opcode] E8 ? ? ? ? 5B 5E 83 C4 18 And if you scan for the pattern, you might find yourself at a different address. 0060913F 024 E8 [7C 13 00 00] call ChangeStrategyMode // <= Here 00609144 024 5B pop ebx Auto-create pattern will often generate a pattern to some code that call (s) the function you are looking for. In order to convert this to the actual function address at runtime, you will need to do the following. Extract the relative address [shown in brackets] from the call instruction (in this case bytes 0x7C130000). Add this relative address to address of next instruction. // Reference C# code to do this: // instructionAddress: Address of found signature in RAM. // instructionLength: Length of the instruction. unsafe byte * CallInstructionToAbsoluteAddress ( byte * instructionAddress , int instructionLength ) { var nextInstructionAddress = instructionAddress + instructionLength ; var offset = *( instructionAddress + 1 ); // extract [ 7C 13 00 00 ] return ( nextInstructionAddress + offset ); } If the signature scan result says sig to containing function , add the number in brackets to your result.","title":"Auto Create Pattern"},{"location":"CheatSheet/SignatureScanning/#tool-makesig-for-ghidra","text":"You can find MakeSig here . To install simply drop makesig.py into your ghidra_scripts directory. If you do not know where this directory is, you can check in Window -> Script Manager (or using the Script Manager button in the toolbar) then Right Click -> Script Directories . The default directory is ~/ghidra_scripts although in this window you can add another directory where scripts will be searched for. With the script installed you can then use it from the Script Manager window by searching for makesig and double clicking it. You can also assign a keyboard shortcut to run the script by Right Click -> Assign Key Binding . After running it once you can also rerun it with Ctrl + Shift + R or using the rerun button at the end of the toolbar. When running the script you can either create a signature for the start of the function or the currently selected instruction, the found signature such as E8 ?? ?? ?? ?? 8B 45 ?? 89 47 will be printed to the console.","title":"Tool: MakeSig For Ghidra"},{"location":"CheatSheet/SignatureScanning/#searching-for-signatures","text":"Info The following example makes use of the Reloaded.Memory.SigScan NuGet library. You can find its documentation here . The following is an example of how you would search for the signature in the Creating Signatures section above: // Initialize the scanner. var thisProcess = Process . GetCurrentProcess (); var baseAddress = thisProcess . MainModule . BaseAddress ; var exeSize = thisProcess . MainModule . ModuleMemorySize ; using var scanner = new Scanner (( byte *) baseAddress , exeSize ); // Search for a given pattern // Note: If created signature using SigMaker, replace ? with ??. var result = scanner . FindPattern ( \"89 15 ?? ?? ?? ?? EB ?? A3 ?? ?? ?? ??\" ); if (! result . Found ) throw new Exception ( \"Signature for getting LevelId not found.\" ); // Address of `mov levelId, edx` var codeAddress = baseAddress + result . Offset ; // Address of `levelId` (skip 89 15) var levelIdPointer = ( int **)( codeAddress + 2 ); // Get address of 'levelId' in memory. int * levelId = * levelIdPointer ;","title":"Searching for Signatures"},{"location":"CheatSheet/SignatureScanning/#additional-resources","text":"Guided Hacking: Pattern Scanning Guide AlliedMods: Pattern Scanning Reloaded Wiki","title":"Additional Resources"}]}